{"ast":null,"code":"function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport findDOMNode from \"rc-util/es/Dom/findDOMNode\";\n/**\n * Our algorithm have additional one ghost item\n * whose index as `data.length` to simplify the calculation\n */\n\nexport var GHOST_ITEM_KEY = '__rc_ghost_item__';\n/**\n * Get location item and its align percentage with the scroll percentage.\n * We should measure current scroll position to decide which item is the location item.\n * And then fill the top count and bottom count with the base of location item.\n *\n * `total` should be the real count instead of `total - 1` in calculation.\n */\n\nfunction getLocationItem(scrollPtg, total) {\n  var itemIndex = Math.floor(scrollPtg * total);\n  var itemTopPtg = itemIndex / total;\n  var itemBottomPtg = (itemIndex + 1) / total;\n  var itemOffsetPtg = (scrollPtg - itemTopPtg) / (itemBottomPtg - itemTopPtg);\n  return {\n    index: itemIndex,\n    offsetPtg: itemOffsetPtg\n  };\n}\n/**\n * Safari has the elasticity effect which provides negative `scrollTop` value.\n * We should ignore it since will make scroll animation shake.\n */\n\n\nexport function alignScrollTop(scrollTop, scrollRange) {\n  if (scrollTop < 0) {\n    return 0;\n  }\n\n  if (scrollTop >= scrollRange) {\n    return scrollRange;\n  }\n\n  return scrollTop;\n}\nexport function getScrollPercentage(_ref) {\n  var scrollTop = _ref.scrollTop,\n      scrollHeight = _ref.scrollHeight,\n      clientHeight = _ref.clientHeight;\n\n  if (scrollHeight <= clientHeight) {\n    return 0;\n  }\n\n  var scrollRange = scrollHeight - clientHeight;\n  var alignedScrollTop = alignScrollTop(scrollTop, scrollRange);\n  var scrollTopPtg = alignedScrollTop / scrollRange;\n  return scrollTopPtg;\n}\nexport function getElementScrollPercentage(element) {\n  if (!element) {\n    return 0;\n  }\n\n  return getScrollPercentage(element);\n}\n/**\n * Get node `offsetHeight`. We prefer node is a dom element directly.\n * But if not provided, downgrade to `findDOMNode` to get the real dom element.\n */\n\nexport function getNodeHeight(node) {\n  var element = findDOMNode(node);\n  return element ? element.offsetHeight : 0;\n}\n/**\n * Get display items start, end, located item index. This is pure math calculation\n */\n\nexport function getRangeIndex(scrollPtg, itemCount, visibleCount) {\n  var _getLocationItem = getLocationItem(scrollPtg, itemCount),\n      index = _getLocationItem.index,\n      offsetPtg = _getLocationItem.offsetPtg;\n\n  var beforeCount = Math.ceil(scrollPtg * visibleCount);\n  var afterCount = Math.ceil((1 - scrollPtg) * visibleCount);\n  return {\n    itemIndex: index,\n    itemOffsetPtg: offsetPtg,\n    startIndex: Math.max(0, index - beforeCount),\n    endIndex: Math.min(itemCount - 1, index + afterCount)\n  };\n}\n/**\n * Calculate the located item related top with current window height\n */\n\nexport function getItemRelativeTop(_ref2) {\n  var itemIndex = _ref2.itemIndex,\n      itemOffsetPtg = _ref2.itemOffsetPtg,\n      itemElementHeights = _ref2.itemElementHeights,\n      scrollPtg = _ref2.scrollPtg,\n      clientHeight = _ref2.clientHeight,\n      getItemKey = _ref2.getItemKey;\n  var locatedItemHeight = itemElementHeights[getItemKey(itemIndex)] || 0;\n  var locatedItemTop = scrollPtg * clientHeight;\n  var locatedItemOffset = itemOffsetPtg * locatedItemHeight;\n  return Math.floor(locatedItemTop - locatedItemOffset);\n}\n/**\n * Calculate the located item absolute top with whole scroll height\n */\n\nexport function getItemAbsoluteTop(_ref3) {\n  var scrollTop = _ref3.scrollTop,\n      rest = _objectWithoutProperties(_ref3, [\"scrollTop\"]);\n\n  return scrollTop + getItemRelativeTop(rest);\n}\nexport function getCompareItemRelativeTop(_ref4) {\n  var locatedItemRelativeTop = _ref4.locatedItemRelativeTop,\n      locatedItemIndex = _ref4.locatedItemIndex,\n      compareItemIndex = _ref4.compareItemIndex,\n      startIndex = _ref4.startIndex,\n      endIndex = _ref4.endIndex,\n      getItemKey = _ref4.getItemKey,\n      itemElementHeights = _ref4.itemElementHeights;\n  var originCompareItemTop = locatedItemRelativeTop;\n  var compareItemKey = getItemKey(compareItemIndex);\n\n  if (compareItemIndex <= locatedItemIndex) {\n    for (var index = locatedItemIndex; index >= startIndex; index -= 1) {\n      var key = getItemKey(index);\n\n      if (key === compareItemKey) {\n        break;\n      }\n\n      var prevItemKey = getItemKey(index - 1);\n      originCompareItemTop -= itemElementHeights[prevItemKey] || 0;\n    }\n  } else {\n    for (var _index = locatedItemIndex; _index <= endIndex; _index += 1) {\n      var _key = getItemKey(_index);\n\n      if (_key === compareItemKey) {\n        break;\n      }\n\n      originCompareItemTop += itemElementHeights[_key] || 0;\n    }\n  }\n\n  return originCompareItemTop;\n}\nexport function requireVirtual(height, itemHeight, count, virtual) {\n  return virtual !== false && typeof height === 'number' && count * itemHeight > height;\n}","map":{"version":3,"names":["_objectWithoutProperties","source","excluded","target","_objectWithoutPropertiesLoose","key","i","Object","getOwnPropertySymbols","sourceSymbolKeys","length","indexOf","prototype","propertyIsEnumerable","call","sourceKeys","keys","findDOMNode","GHOST_ITEM_KEY","getLocationItem","scrollPtg","total","itemIndex","Math","floor","itemTopPtg","itemBottomPtg","itemOffsetPtg","index","offsetPtg","alignScrollTop","scrollTop","scrollRange","getScrollPercentage","_ref","scrollHeight","clientHeight","alignedScrollTop","scrollTopPtg","getElementScrollPercentage","element","getNodeHeight","node","offsetHeight","getRangeIndex","itemCount","visibleCount","_getLocationItem","beforeCount","ceil","afterCount","startIndex","max","endIndex","min","getItemRelativeTop","_ref2","itemElementHeights","getItemKey","locatedItemHeight","locatedItemTop","locatedItemOffset","getItemAbsoluteTop","_ref3","rest","getCompareItemRelativeTop","_ref4","locatedItemRelativeTop","locatedItemIndex","compareItemIndex","originCompareItemTop","compareItemKey","prevItemKey","_index","_key","requireVirtual","height","itemHeight","count","virtual"],"sources":["E:/Work/PFE/Project folder/react/node_modules/rc-tree/node_modules/rc-virtual-list/es/utils/itemUtil.js"],"sourcesContent":["function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport findDOMNode from \"rc-util/es/Dom/findDOMNode\";\n/**\n * Our algorithm have additional one ghost item\n * whose index as `data.length` to simplify the calculation\n */\n\nexport var GHOST_ITEM_KEY = '__rc_ghost_item__';\n/**\n * Get location item and its align percentage with the scroll percentage.\n * We should measure current scroll position to decide which item is the location item.\n * And then fill the top count and bottom count with the base of location item.\n *\n * `total` should be the real count instead of `total - 1` in calculation.\n */\n\nfunction getLocationItem(scrollPtg, total) {\n  var itemIndex = Math.floor(scrollPtg * total);\n  var itemTopPtg = itemIndex / total;\n  var itemBottomPtg = (itemIndex + 1) / total;\n  var itemOffsetPtg = (scrollPtg - itemTopPtg) / (itemBottomPtg - itemTopPtg);\n  return {\n    index: itemIndex,\n    offsetPtg: itemOffsetPtg\n  };\n}\n/**\n * Safari has the elasticity effect which provides negative `scrollTop` value.\n * We should ignore it since will make scroll animation shake.\n */\n\n\nexport function alignScrollTop(scrollTop, scrollRange) {\n  if (scrollTop < 0) {\n    return 0;\n  }\n\n  if (scrollTop >= scrollRange) {\n    return scrollRange;\n  }\n\n  return scrollTop;\n}\nexport function getScrollPercentage(_ref) {\n  var scrollTop = _ref.scrollTop,\n      scrollHeight = _ref.scrollHeight,\n      clientHeight = _ref.clientHeight;\n\n  if (scrollHeight <= clientHeight) {\n    return 0;\n  }\n\n  var scrollRange = scrollHeight - clientHeight;\n  var alignedScrollTop = alignScrollTop(scrollTop, scrollRange);\n  var scrollTopPtg = alignedScrollTop / scrollRange;\n  return scrollTopPtg;\n}\nexport function getElementScrollPercentage(element) {\n  if (!element) {\n    return 0;\n  }\n\n  return getScrollPercentage(element);\n}\n/**\n * Get node `offsetHeight`. We prefer node is a dom element directly.\n * But if not provided, downgrade to `findDOMNode` to get the real dom element.\n */\n\nexport function getNodeHeight(node) {\n  var element = findDOMNode(node);\n  return element ? element.offsetHeight : 0;\n}\n/**\n * Get display items start, end, located item index. This is pure math calculation\n */\n\nexport function getRangeIndex(scrollPtg, itemCount, visibleCount) {\n  var _getLocationItem = getLocationItem(scrollPtg, itemCount),\n      index = _getLocationItem.index,\n      offsetPtg = _getLocationItem.offsetPtg;\n\n  var beforeCount = Math.ceil(scrollPtg * visibleCount);\n  var afterCount = Math.ceil((1 - scrollPtg) * visibleCount);\n  return {\n    itemIndex: index,\n    itemOffsetPtg: offsetPtg,\n    startIndex: Math.max(0, index - beforeCount),\n    endIndex: Math.min(itemCount - 1, index + afterCount)\n  };\n}\n/**\n * Calculate the located item related top with current window height\n */\n\nexport function getItemRelativeTop(_ref2) {\n  var itemIndex = _ref2.itemIndex,\n      itemOffsetPtg = _ref2.itemOffsetPtg,\n      itemElementHeights = _ref2.itemElementHeights,\n      scrollPtg = _ref2.scrollPtg,\n      clientHeight = _ref2.clientHeight,\n      getItemKey = _ref2.getItemKey;\n  var locatedItemHeight = itemElementHeights[getItemKey(itemIndex)] || 0;\n  var locatedItemTop = scrollPtg * clientHeight;\n  var locatedItemOffset = itemOffsetPtg * locatedItemHeight;\n  return Math.floor(locatedItemTop - locatedItemOffset);\n}\n/**\n * Calculate the located item absolute top with whole scroll height\n */\n\nexport function getItemAbsoluteTop(_ref3) {\n  var scrollTop = _ref3.scrollTop,\n      rest = _objectWithoutProperties(_ref3, [\"scrollTop\"]);\n\n  return scrollTop + getItemRelativeTop(rest);\n}\nexport function getCompareItemRelativeTop(_ref4) {\n  var locatedItemRelativeTop = _ref4.locatedItemRelativeTop,\n      locatedItemIndex = _ref4.locatedItemIndex,\n      compareItemIndex = _ref4.compareItemIndex,\n      startIndex = _ref4.startIndex,\n      endIndex = _ref4.endIndex,\n      getItemKey = _ref4.getItemKey,\n      itemElementHeights = _ref4.itemElementHeights;\n  var originCompareItemTop = locatedItemRelativeTop;\n  var compareItemKey = getItemKey(compareItemIndex);\n\n  if (compareItemIndex <= locatedItemIndex) {\n    for (var index = locatedItemIndex; index >= startIndex; index -= 1) {\n      var key = getItemKey(index);\n\n      if (key === compareItemKey) {\n        break;\n      }\n\n      var prevItemKey = getItemKey(index - 1);\n      originCompareItemTop -= itemElementHeights[prevItemKey] || 0;\n    }\n  } else {\n    for (var _index = locatedItemIndex; _index <= endIndex; _index += 1) {\n      var _key = getItemKey(_index);\n\n      if (_key === compareItemKey) {\n        break;\n      }\n\n      originCompareItemTop += itemElementHeights[_key] || 0;\n    }\n  }\n\n  return originCompareItemTop;\n}\nexport function requireVirtual(height, itemHeight, count, virtual) {\n  return virtual !== false && typeof height === 'number' && count * itemHeight > height;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}