{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule insertFragmentIntoContentState\n * @format\n * \n */\n'use strict';\n\nvar BlockMapBuilder = require('./BlockMapBuilder');\n\nvar ContentBlockNode = require('./ContentBlockNode');\n\nvar Immutable = require('immutable');\n\nvar insertIntoList = require('./insertIntoList');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar randomizeBlockMapKeys = require('./randomizeBlockMapKeys');\n\nvar List = Immutable.List;\n\nvar updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {\n  var targetBlock = blockMap.get(targetKey);\n  var text = targetBlock.getText();\n  var chars = targetBlock.getCharacterList();\n  var finalKey = targetKey;\n  var finalOffset = targetOffset + fragmentBlock.getText().length;\n  var newBlock = targetBlock.merge({\n    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),\n    characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),\n    data: fragmentBlock.getData()\n  });\n  return contentState.merge({\n    blockMap: blockMap.set(targetKey, newBlock),\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n/**\n * Appends text/characterList from the fragment first block to\n * target block.\n */\n\n\nvar updateHead = function updateHead(block, targetOffset, fragment) {\n  var text = block.getText();\n  var chars = block.getCharacterList(); // Modify head portion of block.\n\n  var headText = text.slice(0, targetOffset);\n  var headCharacters = chars.slice(0, targetOffset);\n  var appendToHead = fragment.first();\n  return block.merge({\n    text: headText + appendToHead.getText(),\n    characterList: headCharacters.concat(appendToHead.getCharacterList()),\n    type: headText ? block.getType() : appendToHead.getType(),\n    data: appendToHead.getData()\n  });\n};\n/**\n * Appends offset text/characterList from the target block to the last\n * fragment block.\n */\n\n\nvar updateTail = function updateTail(block, targetOffset, fragment) {\n  // Modify tail portion of block.\n  var text = block.getText();\n  var chars = block.getCharacterList(); // Modify head portion of block.\n\n  var blockSize = text.length;\n  var tailText = text.slice(targetOffset, blockSize);\n  var tailCharacters = chars.slice(targetOffset, blockSize);\n  var prependToTail = fragment.last();\n  return prependToTail.merge({\n    text: prependToTail.getText() + tailText,\n    characterList: prependToTail.getCharacterList().concat(tailCharacters),\n    data: prependToTail.getData()\n  });\n};\n\nvar getRootBlocks = function getRootBlocks(block, blockMap) {\n  var headKey = block.getKey();\n  var rootBlock = block;\n  var rootBlocks = []; // sometimes the fragment head block will not be part of the blockMap itself this can happen when\n  // the fragment head is used to update the target block, however when this does not happen we need\n  // to make sure that we include it on the rootBlocks since the first block of a fragment is always a\n  // fragment root block\n\n  if (blockMap.get(headKey)) {\n    rootBlocks.push(headKey);\n  }\n\n  while (rootBlock && rootBlock.getNextSiblingKey()) {\n    var lastSiblingKey = rootBlock.getNextSiblingKey();\n\n    if (!lastSiblingKey) {\n      break;\n    }\n\n    rootBlocks.push(lastSiblingKey);\n    rootBlock = blockMap.get(lastSiblingKey);\n  }\n\n  return rootBlocks;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {\n  return blockMap.withMutations(function (blockMapState) {\n    var targetKey = targetBlock.getKey();\n    var headKey = fragmentHeadBlock.getKey();\n    var targetNextKey = targetBlock.getNextSiblingKey();\n    var targetParentKey = targetBlock.getParentKey();\n    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);\n    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];\n\n    if (blockMapState.get(headKey)) {\n      // update the fragment head when it is part of the blockMap otherwise\n      blockMapState.setIn([targetKey, 'nextSibling'], headKey);\n      blockMapState.setIn([headKey, 'prevSibling'], targetKey);\n    } else {\n      // update the target block that had the fragment head contents merged into it\n      blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());\n      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);\n    } // update the last root block fragment\n\n\n    blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey); // update the original target next block\n\n    if (targetNextKey) {\n      blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);\n    } // update fragment parent links\n\n\n    fragmentRootBlocks.forEach(function (blockKey) {\n      return blockMapState.setIn([blockKey, 'parent'], targetParentKey);\n    }); // update targetBlock parent child links\n\n    if (targetParentKey) {\n      var targetParent = blockMap.get(targetParentKey);\n      var originalTargetParentChildKeys = targetParent.getChildKeys();\n      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);\n      var insertionIndex = targetBlockIndex + 1;\n      var newChildrenKeysArray = originalTargetParentChildKeys.toArray(); // insert fragment children\n\n      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));\n      blockMapState.setIn([targetParentKey, 'children'], List(newChildrenKeysArray));\n    }\n  });\n};\n\nvar insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n  var newBlockArr = [];\n  var fragmentSize = fragment.size;\n  var target = blockMap.get(targetKey);\n  var head = fragment.first();\n  var tail = fragment.last();\n  var finalOffset = tail.getLength();\n  var finalKey = tail.getKey();\n  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());\n  blockMap.forEach(function (block, blockKey) {\n    if (blockKey !== targetKey) {\n      newBlockArr.push(block);\n      return;\n    }\n\n    if (shouldNotUpdateFromFragmentBlock) {\n      newBlockArr.push(block);\n    } else {\n      newBlockArr.push(updateHead(block, targetOffset, fragment));\n    } // Insert fragment blocks after the head and before the tail.\n\n\n    fragment // when we are updating the target block with the head fragment block we skip the first fragment\n    // head since its contents have already been merged with the target block otherwise we include\n    // the whole fragment\n    .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {\n      return newBlockArr.push(fragmentBlock);\n    }); // update tail\n\n    newBlockArr.push(updateTail(block, targetOffset, fragment));\n  });\n  var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);\n\n  if (isTreeBasedBlockMap) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\nvar insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should only be called with a collapsed selection state.') : invariant(false) : void 0;\n  var blockMap = contentState.getBlockMap();\n  var fragment = randomizeBlockMapKeys(fragmentBlockMap);\n  var targetKey = selectionState.getStartKey();\n  var targetOffset = selectionState.getStartOffset();\n  var targetBlock = blockMap.get(targetKey);\n\n  if (targetBlock instanceof ContentBlockNode) {\n    !targetBlock.getChildKeys().isEmpty() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should not be called when a container node is selected.') : invariant(false) : void 0;\n  } // When we insert a fragment with a single block we simply update the target block\n  // with the contents of the inserted fragment block\n\n\n  if (fragment.size === 1) {\n    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset);\n  }\n\n  return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);\n};\n\nmodule.exports = insertFragmentIntoContentState;","map":{"version":3,"names":["BlockMapBuilder","require","ContentBlockNode","Immutable","insertIntoList","invariant","randomizeBlockMapKeys","List","updateExistingBlock","contentState","selectionState","blockMap","fragmentBlock","targetKey","targetOffset","targetBlock","get","text","getText","chars","getCharacterList","finalKey","finalOffset","length","newBlock","merge","slice","characterList","data","getData","set","selectionBefore","selectionAfter","anchorKey","anchorOffset","focusKey","focusOffset","isBackward","updateHead","block","fragment","headText","headCharacters","appendToHead","first","concat","type","getType","updateTail","blockSize","tailText","tailCharacters","prependToTail","last","getRootBlocks","headKey","getKey","rootBlock","rootBlocks","push","getNextSiblingKey","lastSiblingKey","updateBlockMapLinks","originalBlockMap","fragmentHeadBlock","withMutations","blockMapState","targetNextKey","targetParentKey","getParentKey","fragmentRootBlocks","lastRootFragmentBlockKey","setIn","forEach","blockKey","targetParent","originalTargetParentChildKeys","getChildKeys","targetBlockIndex","indexOf","insertionIndex","newChildrenKeysArray","toArray","splice","apply","insertFragment","isTreeBasedBlockMap","newBlockArr","fragmentSize","size","target","head","tail","getLength","shouldNotUpdateFromFragmentBlock","isEmpty","updatedBlockMap","createFromArray","insertFragmentIntoContentState","fragmentBlockMap","isCollapsed","process","env","NODE_ENV","getBlockMap","getStartKey","getStartOffset","module","exports"],"sources":["E:/Work/PFE/Project folder/DocHelp/node_modules/draft-js/lib/insertFragmentIntoContentState.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule insertFragmentIntoContentState\n * @format\n * \n */\n\n'use strict';\n\nvar BlockMapBuilder = require('./BlockMapBuilder');\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\n\nvar insertIntoList = require('./insertIntoList');\nvar invariant = require('fbjs/lib/invariant');\nvar randomizeBlockMapKeys = require('./randomizeBlockMapKeys');\n\nvar List = Immutable.List;\n\n\nvar updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {\n  var targetBlock = blockMap.get(targetKey);\n  var text = targetBlock.getText();\n  var chars = targetBlock.getCharacterList();\n  var finalKey = targetKey;\n  var finalOffset = targetOffset + fragmentBlock.getText().length;\n\n  var newBlock = targetBlock.merge({\n    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),\n    characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),\n    data: fragmentBlock.getData()\n  });\n\n  return contentState.merge({\n    blockMap: blockMap.set(targetKey, newBlock),\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\n/**\n * Appends text/characterList from the fragment first block to\n * target block.\n */\nvar updateHead = function updateHead(block, targetOffset, fragment) {\n  var text = block.getText();\n  var chars = block.getCharacterList();\n\n  // Modify head portion of block.\n  var headText = text.slice(0, targetOffset);\n  var headCharacters = chars.slice(0, targetOffset);\n  var appendToHead = fragment.first();\n\n  return block.merge({\n    text: headText + appendToHead.getText(),\n    characterList: headCharacters.concat(appendToHead.getCharacterList()),\n    type: headText ? block.getType() : appendToHead.getType(),\n    data: appendToHead.getData()\n  });\n};\n\n/**\n * Appends offset text/characterList from the target block to the last\n * fragment block.\n */\nvar updateTail = function updateTail(block, targetOffset, fragment) {\n  // Modify tail portion of block.\n  var text = block.getText();\n  var chars = block.getCharacterList();\n\n  // Modify head portion of block.\n  var blockSize = text.length;\n  var tailText = text.slice(targetOffset, blockSize);\n  var tailCharacters = chars.slice(targetOffset, blockSize);\n  var prependToTail = fragment.last();\n\n  return prependToTail.merge({\n    text: prependToTail.getText() + tailText,\n    characterList: prependToTail.getCharacterList().concat(tailCharacters),\n    data: prependToTail.getData()\n  });\n};\n\nvar getRootBlocks = function getRootBlocks(block, blockMap) {\n  var headKey = block.getKey();\n  var rootBlock = block;\n  var rootBlocks = [];\n\n  // sometimes the fragment head block will not be part of the blockMap itself this can happen when\n  // the fragment head is used to update the target block, however when this does not happen we need\n  // to make sure that we include it on the rootBlocks since the first block of a fragment is always a\n  // fragment root block\n  if (blockMap.get(headKey)) {\n    rootBlocks.push(headKey);\n  }\n\n  while (rootBlock && rootBlock.getNextSiblingKey()) {\n    var lastSiblingKey = rootBlock.getNextSiblingKey();\n\n    if (!lastSiblingKey) {\n      break;\n    }\n\n    rootBlocks.push(lastSiblingKey);\n    rootBlock = blockMap.get(lastSiblingKey);\n  }\n\n  return rootBlocks;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {\n  return blockMap.withMutations(function (blockMapState) {\n    var targetKey = targetBlock.getKey();\n    var headKey = fragmentHeadBlock.getKey();\n    var targetNextKey = targetBlock.getNextSiblingKey();\n    var targetParentKey = targetBlock.getParentKey();\n    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);\n    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];\n\n    if (blockMapState.get(headKey)) {\n      // update the fragment head when it is part of the blockMap otherwise\n      blockMapState.setIn([targetKey, 'nextSibling'], headKey);\n      blockMapState.setIn([headKey, 'prevSibling'], targetKey);\n    } else {\n      // update the target block that had the fragment head contents merged into it\n      blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());\n      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);\n    }\n\n    // update the last root block fragment\n    blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey);\n\n    // update the original target next block\n    if (targetNextKey) {\n      blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);\n    }\n\n    // update fragment parent links\n    fragmentRootBlocks.forEach(function (blockKey) {\n      return blockMapState.setIn([blockKey, 'parent'], targetParentKey);\n    });\n\n    // update targetBlock parent child links\n    if (targetParentKey) {\n      var targetParent = blockMap.get(targetParentKey);\n      var originalTargetParentChildKeys = targetParent.getChildKeys();\n\n      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);\n      var insertionIndex = targetBlockIndex + 1;\n\n      var newChildrenKeysArray = originalTargetParentChildKeys.toArray();\n\n      // insert fragment children\n      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));\n\n      blockMapState.setIn([targetParentKey, 'children'], List(newChildrenKeysArray));\n    }\n  });\n};\n\nvar insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n  var newBlockArr = [];\n  var fragmentSize = fragment.size;\n  var target = blockMap.get(targetKey);\n  var head = fragment.first();\n  var tail = fragment.last();\n  var finalOffset = tail.getLength();\n  var finalKey = tail.getKey();\n  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());\n\n  blockMap.forEach(function (block, blockKey) {\n    if (blockKey !== targetKey) {\n      newBlockArr.push(block);\n      return;\n    }\n\n    if (shouldNotUpdateFromFragmentBlock) {\n      newBlockArr.push(block);\n    } else {\n      newBlockArr.push(updateHead(block, targetOffset, fragment));\n    }\n\n    // Insert fragment blocks after the head and before the tail.\n    fragment\n    // when we are updating the target block with the head fragment block we skip the first fragment\n    // head since its contents have already been merged with the target block otherwise we include\n    // the whole fragment\n    .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {\n      return newBlockArr.push(fragmentBlock);\n    });\n\n    // update tail\n    newBlockArr.push(updateTail(block, targetOffset, fragment));\n  });\n\n  var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);\n\n  if (isTreeBasedBlockMap) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\nvar insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should only be called with a collapsed selection state.') : invariant(false) : void 0;\n\n  var blockMap = contentState.getBlockMap();\n  var fragment = randomizeBlockMapKeys(fragmentBlockMap);\n  var targetKey = selectionState.getStartKey();\n  var targetOffset = selectionState.getStartOffset();\n\n  var targetBlock = blockMap.get(targetKey);\n\n  if (targetBlock instanceof ContentBlockNode) {\n    !targetBlock.getChildKeys().isEmpty() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should not be called when a container node is selected.') : invariant(false) : void 0;\n  }\n\n  // When we insert a fragment with a single block we simply update the target block\n  // with the contents of the inserted fragment block\n  if (fragment.size === 1) {\n    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset);\n  }\n\n  return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);\n};\n\nmodule.exports = insertFragmentIntoContentState;"],"mappings":"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"},"metadata":{},"sourceType":"script"}