{"ast":null,"code":"import { __assign, __extends } from 'tslib';\nimport React from 'react';\nimport normalizeWheel from 'normalize-wheel';\n/**\r\n * Compute the dimension of the crop area based on media size,\r\n * aspect ratio and optionally rotation\r\n */\n\nfunction getCropSize(mediaWidth, mediaHeight, containerWidth, containerHeight, aspect, rotation) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n\n  var _a = rotateSize(mediaWidth, mediaHeight, rotation),\n      width = _a.width,\n      height = _a.height;\n\n  var fittingWidth = Math.min(width, containerWidth);\n  var fittingHeight = Math.min(height, containerHeight);\n\n  if (fittingWidth > fittingHeight * aspect) {\n    return {\n      width: fittingHeight * aspect,\n      height: fittingHeight\n    };\n  }\n\n  return {\n    width: fittingWidth,\n    height: fittingWidth / aspect\n  };\n}\n/**\r\n * Compute media zoom.\r\n * We fit the media into the container with \"max-width: 100%; max-height: 100%;\"\r\n */\n\n\nfunction getMediaZoom(mediaSize) {\n  // Take the axis with more pixels to improve accuracy\n  return mediaSize.width > mediaSize.height ? mediaSize.width / mediaSize.naturalWidth : mediaSize.height / mediaSize.naturalHeight;\n}\n/**\r\n * Ensure a new media position stays in the crop area.\r\n */\n\n\nfunction restrictPosition(position, mediaSize, cropSize, zoom, rotation) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n\n  var _a = rotateSize(mediaSize.width, mediaSize.height, rotation),\n      width = _a.width,\n      height = _a.height;\n\n  return {\n    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),\n    y: restrictPositionCoord(position.y, height, cropSize.height, zoom)\n  };\n}\n\nfunction restrictPositionCoord(position, mediaSize, cropSize, zoom) {\n  var maxPosition = mediaSize * zoom / 2 - cropSize / 2;\n  return clamp(position, -maxPosition, maxPosition);\n}\n\nfunction getDistanceBetweenPoints(pointA, pointB) {\n  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2));\n}\n\nfunction getRotationBetweenPoints(pointA, pointB) {\n  return Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI;\n}\n/**\r\n * Compute the output cropped area of the media in percentages and pixels.\r\n * x/y are the top-left coordinates on the src media\r\n */\n\n\nfunction computeCroppedArea(crop, mediaSize, cropSize, aspect, zoom, rotation, restrictPosition) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n\n  if (restrictPosition === void 0) {\n    restrictPosition = true;\n  } // if the media is rotated by the user, we cannot limit the position anymore\n  // as it might need to be negative.\n\n\n  var limitAreaFn = restrictPosition ? limitArea : noOp;\n  var mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation);\n  var mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation); // calculate the crop area in percentages\n  // in the rotated space\n\n  var croppedAreaPercentages = {\n    x: limitAreaFn(100, ((mediaBBoxSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaBBoxSize.width * 100),\n    y: limitAreaFn(100, ((mediaBBoxSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) / mediaBBoxSize.height * 100),\n    width: limitAreaFn(100, cropSize.width / mediaBBoxSize.width * 100 / zoom),\n    height: limitAreaFn(100, cropSize.height / mediaBBoxSize.height * 100 / zoom)\n  }; // we compute the pixels size naively\n\n  var widthInPixels = Math.round(limitAreaFn(mediaNaturalBBoxSize.width, croppedAreaPercentages.width * mediaNaturalBBoxSize.width / 100));\n  var heightInPixels = Math.round(limitAreaFn(mediaNaturalBBoxSize.height, croppedAreaPercentages.height * mediaNaturalBBoxSize.height / 100));\n  var isImgWiderThanHigh = mediaNaturalBBoxSize.width >= mediaNaturalBBoxSize.height * aspect; // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)\n  // if the media is wider than high, when zoom is 0, the crop height will be equals to image height\n  // thus we want to compute the width from the height and aspect for accuracy.\n  // Otherwise, we compute the height from width and aspect.\n\n  var sizePixels = isImgWiderThanHigh ? {\n    width: Math.round(heightInPixels * aspect),\n    height: heightInPixels\n  } : {\n    width: widthInPixels,\n    height: Math.round(widthInPixels / aspect)\n  };\n\n  var croppedAreaPixels = __assign(__assign({}, sizePixels), {\n    x: Math.round(limitAreaFn(mediaNaturalBBoxSize.width - sizePixels.width, croppedAreaPercentages.x * mediaNaturalBBoxSize.width / 100)),\n    y: Math.round(limitAreaFn(mediaNaturalBBoxSize.height - sizePixels.height, croppedAreaPercentages.y * mediaNaturalBBoxSize.height / 100))\n  });\n\n  return {\n    croppedAreaPercentages: croppedAreaPercentages,\n    croppedAreaPixels: croppedAreaPixels\n  };\n}\n/**\r\n * Ensure the returned value is between 0 and max\r\n */\n\n\nfunction limitArea(max, value) {\n  return Math.min(max, Math.max(0, value));\n}\n\nfunction noOp(_max, value) {\n  return value;\n}\n/**\r\n * Compute crop and zoom from the croppedAreaPercentages.\r\n */\n\n\nfunction getInitialCropFromCroppedAreaPercentages(croppedAreaPercentages, mediaSize, rotation, cropSize, minZoom, maxZoom) {\n  var mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation); // This is the inverse process of computeCroppedArea\n\n  var zoom = clamp(cropSize.width / mediaBBoxSize.width * (100 / croppedAreaPercentages.width), minZoom, maxZoom);\n  var crop = {\n    x: zoom * mediaBBoxSize.width / 2 - cropSize.width / 2 - mediaBBoxSize.width * zoom * (croppedAreaPercentages.x / 100),\n    y: zoom * mediaBBoxSize.height / 2 - cropSize.height / 2 - mediaBBoxSize.height * zoom * (croppedAreaPercentages.y / 100)\n  };\n  return {\n    crop: crop,\n    zoom: zoom\n  };\n}\n/**\r\n * Compute zoom from the croppedAreaPixels\r\n */\n\n\nfunction getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize) {\n  var mediaZoom = getMediaZoom(mediaSize);\n  return cropSize.height > cropSize.width ? cropSize.height / (croppedAreaPixels.height * mediaZoom) : cropSize.width / (croppedAreaPixels.width * mediaZoom);\n}\n/**\r\n * Compute crop and zoom from the croppedAreaPixels\r\n */\n\n\nfunction getInitialCropFromCroppedAreaPixels(croppedAreaPixels, mediaSize, rotation, cropSize, minZoom, maxZoom) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n\n  var mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation);\n  var zoom = clamp(getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize), minZoom, maxZoom);\n  var cropZoom = cropSize.height > cropSize.width ? cropSize.height / croppedAreaPixels.height : cropSize.width / croppedAreaPixels.width;\n  var crop = {\n    x: ((mediaNaturalBBoxSize.width - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,\n    y: ((mediaNaturalBBoxSize.height - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) * cropZoom\n  };\n  return {\n    crop: crop,\n    zoom: zoom\n  };\n}\n/**\r\n * Return the point that is the center of point a and b\r\n */\n\n\nfunction getCenter(a, b) {\n  return {\n    x: (b.x + a.x) / 2,\n    y: (b.y + a.y) / 2\n  };\n}\n\nfunction getRadianAngle(degreeValue) {\n  return degreeValue * Math.PI / 180;\n}\n/**\r\n * Returns the new bounding area of a rotated rectangle.\r\n */\n\n\nfunction rotateSize(width, height, rotation) {\n  var rotRad = getRadianAngle(rotation);\n  return {\n    width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),\n    height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height)\n  };\n}\n/**\r\n * Clamp value between min and max\r\n */\n\n\nfunction clamp(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n/**\r\n * Combine multiple class names into a single string.\r\n */\n\n\nfunction classNames() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  return args.filter(function (value) {\n    if (typeof value === 'string' && value.length > 0) {\n      return true;\n    }\n\n    return false;\n  }).join(' ').trim();\n}\n\nvar css_248z = \".reactEasyCrop_Container {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  right: 0;\\n  bottom: 0;\\n  overflow: hidden;\\n  user-select: none;\\n  touch-action: none;\\n  cursor: move;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n}\\n\\n.reactEasyCrop_Image,\\n.reactEasyCrop_Video {\\n  will-change: transform; /* this improves performances and prevent painting issues on iOS Chrome */\\n}\\n\\n.reactEasyCrop_Contain {\\n  max-width: 100%;\\n  max-height: 100%;\\n  margin: auto;\\n  position: absolute;\\n  top: 0;\\n  bottom: 0;\\n  left: 0;\\n  right: 0;\\n}\\n.reactEasyCrop_Cover_Horizontal {\\n  width: 100%;\\n  height: auto;\\n}\\n.reactEasyCrop_Cover_Vertical {\\n  width: auto;\\n  height: 100%;\\n}\\n\\n.reactEasyCrop_CropArea {\\n  position: absolute;\\n  left: 50%;\\n  top: 50%;\\n  transform: translate(-50%, -50%);\\n  border: 1px solid rgba(255, 255, 255, 0.5);\\n  box-sizing: border-box;\\n  box-shadow: 0 0 0 9999em;\\n  color: rgba(0, 0, 0, 0.5);\\n  overflow: hidden;\\n}\\n\\n.reactEasyCrop_CropAreaRound {\\n  border-radius: 50%;\\n}\\n\\n.reactEasyCrop_CropAreaGrid::before {\\n  content: ' ';\\n  box-sizing: border-box;\\n  position: absolute;\\n  border: 1px solid rgba(255, 255, 255, 0.5);\\n  top: 0;\\n  bottom: 0;\\n  left: 33.33%;\\n  right: 33.33%;\\n  border-top: 0;\\n  border-bottom: 0;\\n}\\n\\n.reactEasyCrop_CropAreaGrid::after {\\n  content: ' ';\\n  box-sizing: border-box;\\n  position: absolute;\\n  border: 1px solid rgba(255, 255, 255, 0.5);\\n  top: 33.33%;\\n  bottom: 33.33%;\\n  left: 0;\\n  right: 0;\\n  border-left: 0;\\n  border-right: 0;\\n}\\n\";\nvar MIN_ZOOM = 1;\nvar MAX_ZOOM = 3;\n\nvar Cropper =\n/** @class */\nfunction (_super) {\n  __extends(Cropper, _super);\n\n  function Cropper() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.imageRef = null;\n    _this.videoRef = null;\n    _this.containerRef = null;\n    _this.styleRef = null;\n    _this.containerRect = null;\n    _this.mediaSize = {\n      width: 0,\n      height: 0,\n      naturalWidth: 0,\n      naturalHeight: 0\n    };\n    _this.dragStartPosition = {\n      x: 0,\n      y: 0\n    };\n    _this.dragStartCrop = {\n      x: 0,\n      y: 0\n    };\n    _this.lastPinchDistance = 0;\n    _this.lastPinchRotation = 0;\n    _this.rafDragTimeout = null;\n    _this.rafPinchTimeout = null;\n    _this.wheelTimer = null;\n    _this.state = {\n      cropSize: null,\n      hasWheelJustStarted: false\n    }; // this is to prevent Safari on iOS >= 10 to zoom the page\n\n    _this.preventZoomSafari = function (e) {\n      return e.preventDefault();\n    };\n\n    _this.cleanEvents = function () {\n      document.removeEventListener('mousemove', _this.onMouseMove);\n      document.removeEventListener('mouseup', _this.onDragStopped);\n      document.removeEventListener('touchmove', _this.onTouchMove);\n      document.removeEventListener('touchend', _this.onDragStopped);\n    };\n\n    _this.clearScrollEvent = function () {\n      if (_this.containerRef) _this.containerRef.removeEventListener('wheel', _this.onWheel);\n\n      if (_this.wheelTimer) {\n        clearTimeout(_this.wheelTimer);\n      }\n    };\n\n    _this.onMediaLoad = function () {\n      var cropSize = _this.computeSizes();\n\n      if (cropSize) {\n        _this.emitCropData();\n\n        _this.setInitialCrop(cropSize);\n      }\n\n      if (_this.props.onMediaLoaded) {\n        _this.props.onMediaLoaded(_this.mediaSize);\n      }\n    };\n\n    _this.setInitialCrop = function (cropSize) {\n      if (_this.props.initialCroppedAreaPercentages) {\n        var _a = getInitialCropFromCroppedAreaPercentages(_this.props.initialCroppedAreaPercentages, _this.mediaSize, _this.props.rotation, cropSize, _this.props.minZoom, _this.props.maxZoom),\n            crop = _a.crop,\n            zoom = _a.zoom;\n\n        _this.props.onCropChange(crop);\n\n        _this.props.onZoomChange && _this.props.onZoomChange(zoom);\n      } else if (_this.props.initialCroppedAreaPixels) {\n        var _b = getInitialCropFromCroppedAreaPixels(_this.props.initialCroppedAreaPixels, _this.mediaSize, _this.props.rotation, cropSize, _this.props.minZoom, _this.props.maxZoom),\n            crop = _b.crop,\n            zoom = _b.zoom;\n\n        _this.props.onCropChange(crop);\n\n        _this.props.onZoomChange && _this.props.onZoomChange(zoom);\n      }\n    };\n\n    _this.computeSizes = function () {\n      var _a, _b, _c, _d, _e, _f;\n\n      var mediaRef = _this.imageRef || _this.videoRef;\n\n      if (mediaRef && _this.containerRef) {\n        _this.containerRect = _this.containerRef.getBoundingClientRect();\n        var containerAspect = _this.containerRect.width / _this.containerRect.height;\n        var naturalWidth = ((_a = _this.imageRef) === null || _a === void 0 ? void 0 : _a.naturalWidth) || ((_b = _this.videoRef) === null || _b === void 0 ? void 0 : _b.videoWidth) || 0;\n        var naturalHeight = ((_c = _this.imageRef) === null || _c === void 0 ? void 0 : _c.naturalHeight) || ((_d = _this.videoRef) === null || _d === void 0 ? void 0 : _d.videoHeight) || 0;\n        var isMediaScaledDown = mediaRef.offsetWidth < naturalWidth || mediaRef.offsetHeight < naturalHeight;\n        var mediaAspect = naturalWidth / naturalHeight; // We do not rely on the offsetWidth/offsetHeight if the media is scaled down\n        // as the values they report are rounded. That will result in precision losses\n        // when calculating zoom. We use the fact that the media is positionned relative\n        // to the container. That allows us to use the container's dimensions\n        // and natural aspect ratio of the media to calculate accurate media size.\n        // However, for this to work, the container should not be rotated\n\n        var renderedMediaSize = void 0;\n\n        if (isMediaScaledDown) {\n          switch (_this.props.objectFit) {\n            default:\n            case 'contain':\n              renderedMediaSize = containerAspect > mediaAspect ? {\n                width: _this.containerRect.height * mediaAspect,\n                height: _this.containerRect.height\n              } : {\n                width: _this.containerRect.width,\n                height: _this.containerRect.width / mediaAspect\n              };\n              break;\n\n            case 'horizontal-cover':\n              renderedMediaSize = {\n                width: _this.containerRect.width,\n                height: _this.containerRect.width / mediaAspect\n              };\n              break;\n\n            case 'vertical-cover':\n              renderedMediaSize = {\n                width: _this.containerRect.height * mediaAspect,\n                height: _this.containerRect.height\n              };\n              break;\n\n            case 'auto-cover':\n              renderedMediaSize = naturalWidth > naturalHeight ? {\n                width: _this.containerRect.width,\n                height: _this.containerRect.width / mediaAspect\n              } : {\n                width: _this.containerRect.height * mediaAspect,\n                height: _this.containerRect.height\n              };\n              break;\n          }\n        } else {\n          renderedMediaSize = {\n            width: mediaRef.offsetWidth,\n            height: mediaRef.offsetHeight\n          };\n        }\n\n        _this.mediaSize = __assign(__assign({}, renderedMediaSize), {\n          naturalWidth: naturalWidth,\n          naturalHeight: naturalHeight\n        });\n        var cropSize = _this.props.cropSize ? _this.props.cropSize : getCropSize(_this.mediaSize.width, _this.mediaSize.height, _this.containerRect.width, _this.containerRect.height, _this.props.aspect, _this.props.rotation);\n\n        if (((_e = _this.state.cropSize) === null || _e === void 0 ? void 0 : _e.height) !== cropSize.height || ((_f = _this.state.cropSize) === null || _f === void 0 ? void 0 : _f.width) !== cropSize.width) {\n          _this.props.onCropSizeChange && _this.props.onCropSizeChange(cropSize);\n        }\n\n        _this.setState({\n          cropSize: cropSize\n        }, _this.recomputeCropPosition);\n\n        return cropSize;\n      }\n    };\n\n    _this.onMouseDown = function (e) {\n      e.preventDefault();\n      document.addEventListener('mousemove', _this.onMouseMove);\n      document.addEventListener('mouseup', _this.onDragStopped);\n\n      _this.onDragStart(Cropper.getMousePoint(e));\n    };\n\n    _this.onMouseMove = function (e) {\n      return _this.onDrag(Cropper.getMousePoint(e));\n    };\n\n    _this.onTouchStart = function (e) {\n      if (_this.props.onTouchRequest && !_this.props.onTouchRequest(e)) {\n        return;\n      }\n\n      document.addEventListener('touchmove', _this.onTouchMove, {\n        passive: false\n      }); // iOS 11 now defaults to passive: true\n\n      document.addEventListener('touchend', _this.onDragStopped);\n\n      if (e.touches.length === 2) {\n        _this.onPinchStart(e);\n      } else if (e.touches.length === 1) {\n        _this.onDragStart(Cropper.getTouchPoint(e.touches[0]));\n      }\n    };\n\n    _this.onTouchMove = function (e) {\n      // Prevent whole page from scrolling on iOS.\n      e.preventDefault();\n\n      if (e.touches.length === 2) {\n        _this.onPinchMove(e);\n      } else if (e.touches.length === 1) {\n        _this.onDrag(Cropper.getTouchPoint(e.touches[0]));\n      }\n    };\n\n    _this.onDragStart = function (_a) {\n      var _b, _c;\n\n      var x = _a.x,\n          y = _a.y;\n      _this.dragStartPosition = {\n        x: x,\n        y: y\n      };\n      _this.dragStartCrop = __assign({}, _this.props.crop);\n      (_c = (_b = _this.props).onInteractionStart) === null || _c === void 0 ? void 0 : _c.call(_b);\n    };\n\n    _this.onDrag = function (_a) {\n      var x = _a.x,\n          y = _a.y;\n      if (_this.rafDragTimeout) window.cancelAnimationFrame(_this.rafDragTimeout);\n      _this.rafDragTimeout = window.requestAnimationFrame(function () {\n        if (!_this.state.cropSize) return;\n        if (x === undefined || y === undefined) return;\n        var offsetX = x - _this.dragStartPosition.x;\n        var offsetY = y - _this.dragStartPosition.y;\n        var requestedPosition = {\n          x: _this.dragStartCrop.x + offsetX,\n          y: _this.dragStartCrop.y + offsetY\n        };\n        var newPosition = _this.props.restrictPosition ? restrictPosition(requestedPosition, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : requestedPosition;\n\n        _this.props.onCropChange(newPosition);\n      });\n    };\n\n    _this.onDragStopped = function () {\n      var _a, _b;\n\n      _this.cleanEvents();\n\n      _this.emitCropData();\n\n      (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n\n    _this.onWheel = function (e) {\n      if (_this.props.onWheelRequest && !_this.props.onWheelRequest(e)) {\n        return;\n      }\n\n      e.preventDefault();\n      var point = Cropper.getMousePoint(e);\n      var pixelY = normalizeWheel(e).pixelY;\n      var newZoom = _this.props.zoom - pixelY * _this.props.zoomSpeed / 200;\n\n      _this.setNewZoom(newZoom, point);\n\n      if (!_this.state.hasWheelJustStarted) {\n        _this.setState({\n          hasWheelJustStarted: true\n        }, function () {\n          var _a, _b;\n\n          return (_b = (_a = _this.props).onInteractionStart) === null || _b === void 0 ? void 0 : _b.call(_a);\n        });\n      }\n\n      if (_this.wheelTimer) {\n        clearTimeout(_this.wheelTimer);\n      }\n\n      _this.wheelTimer = window.setTimeout(function () {\n        return _this.setState({\n          hasWheelJustStarted: false\n        }, function () {\n          var _a, _b;\n\n          return (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n        });\n      }, 250);\n    };\n\n    _this.getPointOnContainer = function (_a) {\n      var x = _a.x,\n          y = _a.y;\n\n      if (!_this.containerRect) {\n        throw new Error('The Cropper is not mounted');\n      }\n\n      return {\n        x: _this.containerRect.width / 2 - (x - _this.containerRect.left),\n        y: _this.containerRect.height / 2 - (y - _this.containerRect.top)\n      };\n    };\n\n    _this.getPointOnMedia = function (_a) {\n      var x = _a.x,\n          y = _a.y;\n      var _b = _this.props,\n          crop = _b.crop,\n          zoom = _b.zoom;\n      return {\n        x: (x + crop.x) / zoom,\n        y: (y + crop.y) / zoom\n      };\n    };\n\n    _this.setNewZoom = function (zoom, point) {\n      if (!_this.state.cropSize || !_this.props.onZoomChange) return;\n\n      var zoomPoint = _this.getPointOnContainer(point);\n\n      var zoomTarget = _this.getPointOnMedia(zoomPoint);\n\n      var newZoom = clamp(zoom, _this.props.minZoom, _this.props.maxZoom);\n      var requestedPosition = {\n        x: zoomTarget.x * newZoom - zoomPoint.x,\n        y: zoomTarget.y * newZoom - zoomPoint.y\n      };\n      var newPosition = _this.props.restrictPosition ? restrictPosition(requestedPosition, _this.mediaSize, _this.state.cropSize, newZoom, _this.props.rotation) : requestedPosition;\n\n      _this.props.onCropChange(newPosition);\n\n      _this.props.onZoomChange(newZoom);\n    };\n\n    _this.getCropData = function () {\n      if (!_this.state.cropSize) {\n        return null;\n      } // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ValentinH/react-easy-crop/issues/6)\n\n\n      var restrictedPosition = _this.props.restrictPosition ? restrictPosition(_this.props.crop, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;\n      return computeCroppedArea(restrictedPosition, _this.mediaSize, _this.state.cropSize, _this.getAspect(), _this.props.zoom, _this.props.rotation, _this.props.restrictPosition);\n    };\n\n    _this.emitCropData = function () {\n      var cropData = _this.getCropData();\n\n      if (!cropData) return;\n      var croppedAreaPercentages = cropData.croppedAreaPercentages,\n          croppedAreaPixels = cropData.croppedAreaPixels;\n\n      if (_this.props.onCropComplete) {\n        _this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels);\n      }\n\n      if (_this.props.onCropAreaChange) {\n        _this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels);\n      }\n    };\n\n    _this.emitCropAreaChange = function () {\n      var cropData = _this.getCropData();\n\n      if (!cropData) return;\n      var croppedAreaPercentages = cropData.croppedAreaPercentages,\n          croppedAreaPixels = cropData.croppedAreaPixels;\n\n      if (_this.props.onCropAreaChange) {\n        _this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels);\n      }\n    };\n\n    _this.recomputeCropPosition = function () {\n      if (!_this.state.cropSize) return;\n      var newPosition = _this.props.restrictPosition ? restrictPosition(_this.props.crop, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;\n\n      _this.props.onCropChange(newPosition);\n\n      _this.emitCropData();\n    };\n\n    return _this;\n  }\n\n  Cropper.prototype.componentDidMount = function () {\n    window.addEventListener('resize', this.computeSizes);\n\n    if (this.containerRef) {\n      this.props.zoomWithScroll && this.containerRef.addEventListener('wheel', this.onWheel, {\n        passive: false\n      });\n      this.containerRef.addEventListener('gesturestart', this.preventZoomSafari);\n      this.containerRef.addEventListener('gesturechange', this.preventZoomSafari);\n    }\n\n    if (!this.props.disableAutomaticStylesInjection) {\n      this.styleRef = document.createElement('style');\n      this.styleRef.setAttribute('type', 'text/css');\n      this.styleRef.innerHTML = css_248z;\n      document.head.appendChild(this.styleRef);\n    } // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called\n\n\n    if (this.imageRef && this.imageRef.complete) {\n      this.onMediaLoad();\n    }\n  };\n\n  Cropper.prototype.componentWillUnmount = function () {\n    var _a;\n\n    window.removeEventListener('resize', this.computeSizes);\n\n    if (this.containerRef) {\n      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari);\n      this.containerRef.removeEventListener('gesturechange', this.preventZoomSafari);\n    }\n\n    if (this.styleRef) {\n      (_a = this.styleRef.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this.styleRef);\n    }\n\n    this.cleanEvents();\n    this.props.zoomWithScroll && this.clearScrollEvent();\n  };\n\n  Cropper.prototype.componentDidUpdate = function (prevProps) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n    if (prevProps.rotation !== this.props.rotation) {\n      this.computeSizes();\n      this.recomputeCropPosition();\n    } else if (prevProps.aspect !== this.props.aspect) {\n      this.computeSizes();\n    } else if (prevProps.zoom !== this.props.zoom) {\n      this.recomputeCropPosition();\n    } else if (((_a = prevProps.cropSize) === null || _a === void 0 ? void 0 : _a.height) !== ((_b = this.props.cropSize) === null || _b === void 0 ? void 0 : _b.height) || ((_c = prevProps.cropSize) === null || _c === void 0 ? void 0 : _c.width) !== ((_d = this.props.cropSize) === null || _d === void 0 ? void 0 : _d.width)) {\n      this.computeSizes();\n    } else if (((_e = prevProps.crop) === null || _e === void 0 ? void 0 : _e.x) !== ((_f = this.props.crop) === null || _f === void 0 ? void 0 : _f.x) || ((_g = prevProps.crop) === null || _g === void 0 ? void 0 : _g.y) !== ((_h = this.props.crop) === null || _h === void 0 ? void 0 : _h.y)) {\n      this.emitCropAreaChange();\n    }\n\n    if (prevProps.zoomWithScroll !== this.props.zoomWithScroll && this.containerRef) {\n      this.props.zoomWithScroll ? this.containerRef.addEventListener('wheel', this.onWheel, {\n        passive: false\n      }) : this.clearScrollEvent();\n    }\n\n    if (prevProps.video !== this.props.video) {\n      (_j = this.videoRef) === null || _j === void 0 ? void 0 : _j.load();\n    }\n  };\n\n  Cropper.prototype.getAspect = function () {\n    var _a = this.props,\n        cropSize = _a.cropSize,\n        aspect = _a.aspect;\n\n    if (cropSize) {\n      return cropSize.width / cropSize.height;\n    }\n\n    return aspect;\n  };\n\n  Cropper.prototype.onPinchStart = function (e) {\n    var pointA = Cropper.getTouchPoint(e.touches[0]);\n    var pointB = Cropper.getTouchPoint(e.touches[1]);\n    this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB);\n    this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB);\n    this.onDragStart(getCenter(pointA, pointB));\n  };\n\n  Cropper.prototype.onPinchMove = function (e) {\n    var _this = this;\n\n    var pointA = Cropper.getTouchPoint(e.touches[0]);\n    var pointB = Cropper.getTouchPoint(e.touches[1]);\n    var center = getCenter(pointA, pointB);\n    this.onDrag(center);\n    if (this.rafPinchTimeout) window.cancelAnimationFrame(this.rafPinchTimeout);\n    this.rafPinchTimeout = window.requestAnimationFrame(function () {\n      var distance = getDistanceBetweenPoints(pointA, pointB);\n      var newZoom = _this.props.zoom * (distance / _this.lastPinchDistance);\n\n      _this.setNewZoom(newZoom, center);\n\n      _this.lastPinchDistance = distance;\n      var rotation = getRotationBetweenPoints(pointA, pointB);\n      var newRotation = _this.props.rotation + (rotation - _this.lastPinchRotation);\n      _this.props.onRotationChange && _this.props.onRotationChange(newRotation);\n      _this.lastPinchRotation = rotation;\n    });\n  };\n\n  Cropper.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        image = _a.image,\n        video = _a.video,\n        mediaProps = _a.mediaProps,\n        transform = _a.transform,\n        _b = _a.crop,\n        x = _b.x,\n        y = _b.y,\n        rotation = _a.rotation,\n        zoom = _a.zoom,\n        cropShape = _a.cropShape,\n        showGrid = _a.showGrid,\n        _c = _a.style,\n        containerStyle = _c.containerStyle,\n        cropAreaStyle = _c.cropAreaStyle,\n        mediaStyle = _c.mediaStyle,\n        _d = _a.classes,\n        containerClassName = _d.containerClassName,\n        cropAreaClassName = _d.cropAreaClassName,\n        mediaClassName = _d.mediaClassName,\n        objectFit = _a.objectFit;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      onMouseDown: this.onMouseDown,\n      onTouchStart: this.onTouchStart,\n      ref: function ref(el) {\n        return _this.containerRef = el;\n      },\n      \"data-testid\": \"container\",\n      style: containerStyle,\n      className: classNames('reactEasyCrop_Container', containerClassName)\n    }, image ? /*#__PURE__*/React.createElement(\"img\", __assign({\n      alt: \"\",\n      className: classNames('reactEasyCrop_Image', objectFit === 'contain' && 'reactEasyCrop_Contain', objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal', objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical', objectFit === 'auto-cover' && (this.mediaSize.naturalWidth > this.mediaSize.naturalHeight ? 'reactEasyCrop_Cover_Horizontal' : 'reactEasyCrop_Cover_Vertical'), mediaClassName)\n    }, mediaProps, {\n      src: image,\n      ref: function ref(el) {\n        return _this.imageRef = el;\n      },\n      style: __assign(__assign({}, mediaStyle), {\n        transform: transform || \"translate(\" + x + \"px, \" + y + \"px) rotate(\" + rotation + \"deg) scale(\" + zoom + \")\"\n      }),\n      onLoad: this.onMediaLoad\n    })) : video && /*#__PURE__*/React.createElement(\"video\", __assign({\n      autoPlay: true,\n      loop: true,\n      muted: true,\n      className: classNames('reactEasyCrop_Video', objectFit === 'contain' && 'reactEasyCrop_Contain', objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal', objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical', objectFit === 'auto-cover' && (this.mediaSize.naturalWidth > this.mediaSize.naturalHeight ? 'reactEasyCrop_Cover_Horizontal' : 'reactEasyCrop_Cover_Vertical'), mediaClassName)\n    }, mediaProps, {\n      ref: function ref(el) {\n        return _this.videoRef = el;\n      },\n      onLoadedMetadata: this.onMediaLoad,\n      style: __assign(__assign({}, mediaStyle), {\n        transform: transform || \"translate(\" + x + \"px, \" + y + \"px) rotate(\" + rotation + \"deg) scale(\" + zoom + \")\"\n      }),\n      controls: false\n    }), (Array.isArray(video) ? video : [{\n      src: video\n    }]).map(function (item) {\n      return /*#__PURE__*/React.createElement(\"source\", __assign({\n        key: item.src\n      }, item));\n    })), this.state.cropSize && /*#__PURE__*/React.createElement(\"div\", {\n      style: __assign(__assign({}, cropAreaStyle), {\n        width: this.state.cropSize.width,\n        height: this.state.cropSize.height\n      }),\n      \"data-testid\": \"cropper\",\n      className: classNames('reactEasyCrop_CropArea', cropShape === 'round' && 'reactEasyCrop_CropAreaRound', showGrid && 'reactEasyCrop_CropAreaGrid', cropAreaClassName)\n    }));\n  };\n\n  Cropper.defaultProps = {\n    zoom: 1,\n    rotation: 0,\n    aspect: 4 / 3,\n    maxZoom: MAX_ZOOM,\n    minZoom: MIN_ZOOM,\n    cropShape: 'rect',\n    objectFit: 'contain',\n    showGrid: true,\n    style: {},\n    classes: {},\n    mediaProps: {},\n    zoomSpeed: 1,\n    restrictPosition: true,\n    zoomWithScroll: true\n  };\n\n  Cropper.getMousePoint = function (e) {\n    return {\n      x: Number(e.clientX),\n      y: Number(e.clientY)\n    };\n  };\n\n  Cropper.getTouchPoint = function (touch) {\n    return {\n      x: Number(touch.clientX),\n      y: Number(touch.clientY)\n    };\n  };\n\n  return Cropper;\n}(React.Component);\n\nexport default Cropper;","map":{"version":3,"sources":["../src/helpers.ts","../src/Cropper.tsx"],"names":["getCropSize","mediaWidth","mediaHeight","containerWidth","containerHeight","aspect","width","height","rotateSize","fittingWidth","Math","fittingHeight","getMediaZoom","mediaSize","restrictPosition","position","cropSize","zoom","x","restrictPositionCoord","y","maxPosition","clamp","getDistanceBetweenPoints","pointA","pointB","getRotationBetweenPoints","computeCroppedArea","crop","limitAreaFn","mediaBBoxSize","mediaNaturalBBoxSize","croppedAreaPercentages","widthInPixels","heightInPixels","isImgWiderThanHigh","sizePixels","croppedAreaPixels","getInitialCropFromCroppedAreaPercentages","rotation","minZoom","maxZoom","mediaZoom","getInitialCropFromCroppedAreaPixels","getZoomFromCroppedAreaPixels","cropZoom","getCenter","a","b","getRadianAngle","degreeValue","rotRad","value","min","max","classNames","MIN_ZOOM","MAX_ZOOM","__extends","Component","Cropper","cropShape","objectFit","showGrid","style","classes","mediaProps","zoomSpeed","zoomWithScroll","_this","naturalWidth","naturalHeight","hasWheelJustStarted","window","passive","document","removeChild","prevProps","clearTimeout","mediaRef","containerAspect","imageRef","videoRef","isMediaScaledDown","mediaAspect","renderedMediaSize","offsetHeight","Number","e","touch","offsetX","offsetY","requestedPosition","newPosition","center","distance","newZoom","newRotation","point","normalizeWheel","pixelY","onInteractionStart","onInteractionEnd","zoomPoint","zoomTarget","restrictedPosition","cropData","image","video","transform","_b","_c","containerStyle","cropAreaStyle","mediaStyle","_d","containerClassName","cropAreaClassName","mediaClassName","onMouseDown","onTouchStart","ref","className","alt","src","onLoad","onMediaLoad","autoPlay","loop","muted","onLoadedMetadata","controls","Array","key","item"],"mappings":"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","sourcesContent":["import { Area, MediaSize, Point, Size } from './types'\n\n/**\n * Compute the dimension of the crop area based on media size,\n * aspect ratio and optionally rotation\n */\nexport function getCropSize(\n  mediaWidth: number,\n  mediaHeight: number,\n  containerWidth: number,\n  containerHeight: number,\n  aspect: number,\n  rotation = 0\n): Size {\n  const { width, height } = rotateSize(mediaWidth, mediaHeight, rotation)\n  const fittingWidth = Math.min(width, containerWidth)\n  const fittingHeight = Math.min(height, containerHeight)\n\n  if (fittingWidth > fittingHeight * aspect) {\n    return {\n      width: fittingHeight * aspect,\n      height: fittingHeight,\n    }\n  }\n\n  return {\n    width: fittingWidth,\n    height: fittingWidth / aspect,\n  }\n}\n\n/**\n * Compute media zoom.\n * We fit the media into the container with \"max-width: 100%; max-height: 100%;\"\n */\nexport function getMediaZoom(mediaSize: MediaSize) {\n  // Take the axis with more pixels to improve accuracy\n  return mediaSize.width > mediaSize.height\n    ? mediaSize.width / mediaSize.naturalWidth\n    : mediaSize.height / mediaSize.naturalHeight\n}\n\n/**\n * Ensure a new media position stays in the crop area.\n */\nexport function restrictPosition(\n  position: Point,\n  mediaSize: Size,\n  cropSize: Size,\n  zoom: number,\n  rotation = 0\n): Point {\n  const { width, height } = rotateSize(mediaSize.width, mediaSize.height, rotation)\n\n  return {\n    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),\n    y: restrictPositionCoord(position.y, height, cropSize.height, zoom),\n  }\n}\n\nfunction restrictPositionCoord(\n  position: number,\n  mediaSize: number,\n  cropSize: number,\n  zoom: number\n): number {\n  const maxPosition = (mediaSize * zoom) / 2 - cropSize / 2\n\n  return clamp(position, -maxPosition, maxPosition)\n}\n\nexport function getDistanceBetweenPoints(pointA: Point, pointB: Point) {\n  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2))\n}\n\nexport function getRotationBetweenPoints(pointA: Point, pointB: Point) {\n  return (Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180) / Math.PI\n}\n\n/**\n * Compute the output cropped area of the media in percentages and pixels.\n * x/y are the top-left coordinates on the src media\n */\nexport function computeCroppedArea(\n  crop: Point,\n  mediaSize: MediaSize,\n  cropSize: Size,\n  aspect: number,\n  zoom: number,\n  rotation = 0,\n  restrictPosition = true\n): { croppedAreaPercentages: Area; croppedAreaPixels: Area } {\n  // if the media is rotated by the user, we cannot limit the position anymore\n  // as it might need to be negative.\n  const limitAreaFn = restrictPosition ? limitArea : noOp\n\n  const mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation)\n  const mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation)\n\n  // calculate the crop area in percentages\n  // in the rotated space\n  const croppedAreaPercentages = {\n    x: limitAreaFn(\n      100,\n      (((mediaBBoxSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaBBoxSize.width) *\n        100\n    ),\n    y: limitAreaFn(\n      100,\n      (((mediaBBoxSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) /\n        mediaBBoxSize.height) *\n        100\n    ),\n    width: limitAreaFn(100, ((cropSize.width / mediaBBoxSize.width) * 100) / zoom),\n    height: limitAreaFn(100, ((cropSize.height / mediaBBoxSize.height) * 100) / zoom),\n  }\n\n  // we compute the pixels size naively\n  const widthInPixels = Math.round(\n    limitAreaFn(\n      mediaNaturalBBoxSize.width,\n      (croppedAreaPercentages.width * mediaNaturalBBoxSize.width) / 100\n    )\n  )\n  const heightInPixels = Math.round(\n    limitAreaFn(\n      mediaNaturalBBoxSize.height,\n      (croppedAreaPercentages.height * mediaNaturalBBoxSize.height) / 100\n    )\n  )\n  const isImgWiderThanHigh = mediaNaturalBBoxSize.width >= mediaNaturalBBoxSize.height * aspect\n\n  // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)\n  // if the media is wider than high, when zoom is 0, the crop height will be equals to image height\n  // thus we want to compute the width from the height and aspect for accuracy.\n  // Otherwise, we compute the height from width and aspect.\n  const sizePixels = isImgWiderThanHigh\n    ? {\n        width: Math.round(heightInPixels * aspect),\n        height: heightInPixels,\n      }\n    : {\n        width: widthInPixels,\n        height: Math.round(widthInPixels / aspect),\n      }\n\n  const croppedAreaPixels = {\n    ...sizePixels,\n    x: Math.round(\n      limitAreaFn(\n        mediaNaturalBBoxSize.width - sizePixels.width,\n        (croppedAreaPercentages.x * mediaNaturalBBoxSize.width) / 100\n      )\n    ),\n    y: Math.round(\n      limitAreaFn(\n        mediaNaturalBBoxSize.height - sizePixels.height,\n        (croppedAreaPercentages.y * mediaNaturalBBoxSize.height) / 100\n      )\n    ),\n  }\n\n  return { croppedAreaPercentages, croppedAreaPixels }\n}\n\n/**\n * Ensure the returned value is between 0 and max\n */\nfunction limitArea(max: number, value: number): number {\n  return Math.min(max, Math.max(0, value))\n}\n\nfunction noOp(_max: number, value: number) {\n  return value\n}\n\n/**\n * Compute crop and zoom from the croppedAreaPercentages.\n */\nexport function getInitialCropFromCroppedAreaPercentages(\n  croppedAreaPercentages: Area,\n  mediaSize: MediaSize,\n  rotation: number,\n  cropSize: Size,\n  minZoom: number,\n  maxZoom: number\n) {\n  const mediaBBoxSize = rotateSize(mediaSize.width, mediaSize.height, rotation)\n\n  // This is the inverse process of computeCroppedArea\n  const zoom = clamp(\n    (cropSize.width / mediaBBoxSize.width) * (100 / croppedAreaPercentages.width),\n    minZoom,\n    maxZoom\n  )\n\n  const crop = {\n    x:\n      (zoom * mediaBBoxSize.width) / 2 -\n      cropSize.width / 2 -\n      mediaBBoxSize.width * zoom * (croppedAreaPercentages.x / 100),\n    y:\n      (zoom * mediaBBoxSize.height) / 2 -\n      cropSize.height / 2 -\n      mediaBBoxSize.height * zoom * (croppedAreaPercentages.y / 100),\n  }\n\n  return { crop, zoom }\n}\n\n/**\n * Compute zoom from the croppedAreaPixels\n */\nfunction getZoomFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  cropSize: Size\n): number {\n  const mediaZoom = getMediaZoom(mediaSize)\n\n  return cropSize.height > cropSize.width\n    ? cropSize.height / (croppedAreaPixels.height * mediaZoom)\n    : cropSize.width / (croppedAreaPixels.width * mediaZoom)\n}\n\n/**\n * Compute crop and zoom from the croppedAreaPixels\n */\nexport function getInitialCropFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  rotation = 0,\n  cropSize: Size,\n  minZoom: number,\n  maxZoom: number\n): { crop: Point; zoom: number } {\n  const mediaNaturalBBoxSize = rotateSize(mediaSize.naturalWidth, mediaSize.naturalHeight, rotation)\n\n  const zoom = clamp(\n    getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize),\n    minZoom,\n    maxZoom\n  )\n\n  const cropZoom =\n    cropSize.height > cropSize.width\n      ? cropSize.height / croppedAreaPixels.height\n      : cropSize.width / croppedAreaPixels.width\n\n  const crop = {\n    x:\n      ((mediaNaturalBBoxSize.width - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,\n    y:\n      ((mediaNaturalBBoxSize.height - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) *\n      cropZoom,\n  }\n  return { crop, zoom }\n}\n\n/**\n * Return the point that is the center of point a and b\n */\nexport function getCenter(a: Point, b: Point): Point {\n  return {\n    x: (b.x + a.x) / 2,\n    y: (b.y + a.y) / 2,\n  }\n}\n\nexport function getRadianAngle(degreeValue: number) {\n  return (degreeValue * Math.PI) / 180\n}\n\n/**\n * Returns the new bounding area of a rotated rectangle.\n */\nexport function rotateSize(width: number, height: number, rotation: number): Size {\n  const rotRad = getRadianAngle(rotation)\n\n  return {\n    width: Math.abs(Math.cos(rotRad) * width) + Math.abs(Math.sin(rotRad) * height),\n    height: Math.abs(Math.sin(rotRad) * width) + Math.abs(Math.cos(rotRad) * height),\n  }\n}\n\n/**\n * Clamp value between min and max\n */\nexport function clamp(value: number, min: number, max: number) {\n  return Math.min(Math.max(value, min), max)\n}\n\n/**\n * Combine multiple class names into a single string.\n */\nexport function classNames(...args: (boolean | string | number | undefined | void | null)[]) {\n  return args\n    .filter((value) => {\n      if (typeof value === 'string' && value.length > 0) {\n        return true\n      }\n\n      return false\n    })\n    .join(' ')\n    .trim()\n}\n","import React from 'react'\nimport normalizeWheel from 'normalize-wheel'\nimport { Area, MediaSize, Point, Size, VideoSrc } from './types'\nimport {\n  getCropSize,\n  restrictPosition,\n  getDistanceBetweenPoints,\n  getRotationBetweenPoints,\n  computeCroppedArea,\n  getCenter,\n  getInitialCropFromCroppedAreaPixels,\n  getInitialCropFromCroppedAreaPercentages,\n  classNames,\n  clamp,\n} from './helpers'\nimport cssStyles from './styles.css'\n\nexport type CropperProps = {\n  image?: string\n  video?: string | VideoSrc[]\n  transform?: string\n  crop: Point\n  zoom: number\n  rotation: number\n  aspect: number\n  minZoom: number\n  maxZoom: number\n  cropShape: 'rect' | 'round'\n  cropSize?: Size\n  objectFit?: 'contain' | 'horizontal-cover' | 'vertical-cover' | 'auto-cover'\n  showGrid?: boolean\n  zoomSpeed: number\n  zoomWithScroll?: boolean\n  onCropChange: (location: Point) => void\n  onZoomChange?: (zoom: number) => void\n  onRotationChange?: (rotation: number) => void\n  onCropComplete?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onCropAreaChange?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onCropSizeChange?: (cropSize: Size) => void\n  onInteractionStart?: () => void\n  onInteractionEnd?: () => void\n  onMediaLoaded?: (mediaSize: MediaSize) => void\n  style: {\n    containerStyle?: React.CSSProperties\n    mediaStyle?: React.CSSProperties\n    cropAreaStyle?: React.CSSProperties\n  }\n  classes: {\n    containerClassName?: string\n    mediaClassName?: string\n    cropAreaClassName?: string\n  }\n  restrictPosition: boolean\n  mediaProps: React.ImgHTMLAttributes<HTMLElement> | React.VideoHTMLAttributes<HTMLElement>\n  disableAutomaticStylesInjection?: boolean\n  initialCroppedAreaPixels?: Area\n  initialCroppedAreaPercentages?: Area\n  onTouchRequest?: (e: React.TouchEvent<HTMLDivElement>) => boolean\n  onWheelRequest?: (e: WheelEvent) => boolean\n}\n\ntype State = {\n  cropSize: Size | null\n  hasWheelJustStarted: boolean\n}\n\nconst MIN_ZOOM = 1\nconst MAX_ZOOM = 3\n\nclass Cropper extends React.Component<CropperProps, State> {\n  static defaultProps = {\n    zoom: 1,\n    rotation: 0,\n    aspect: 4 / 3,\n    maxZoom: MAX_ZOOM,\n    minZoom: MIN_ZOOM,\n    cropShape: 'rect' as const,\n    objectFit: 'contain' as const,\n    showGrid: true,\n    style: {},\n    classes: {},\n    mediaProps: {},\n    zoomSpeed: 1,\n    restrictPosition: true,\n    zoomWithScroll: true,\n  }\n\n  imageRef: HTMLImageElement | null = null\n  videoRef: HTMLVideoElement | null = null\n  containerRef: HTMLDivElement | null = null\n  styleRef: HTMLStyleElement | null = null\n  containerRect: DOMRect | null = null\n  mediaSize: MediaSize = { width: 0, height: 0, naturalWidth: 0, naturalHeight: 0 }\n  dragStartPosition: Point = { x: 0, y: 0 }\n  dragStartCrop: Point = { x: 0, y: 0 }\n  lastPinchDistance = 0\n  lastPinchRotation = 0\n  rafDragTimeout: number | null = null\n  rafPinchTimeout: number | null = null\n  wheelTimer: number | null = null\n\n  state: State = {\n    cropSize: null,\n    hasWheelJustStarted: false,\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this.computeSizes)\n    if (this.containerRef) {\n      this.props.zoomWithScroll &&\n        this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n      this.containerRef.addEventListener('gesturestart', this.preventZoomSafari)\n      this.containerRef.addEventListener('gesturechange', this.preventZoomSafari)\n    }\n\n    if (!this.props.disableAutomaticStylesInjection) {\n      this.styleRef = document.createElement('style')\n      this.styleRef.setAttribute('type', 'text/css')\n      this.styleRef.innerHTML = cssStyles\n      document.head.appendChild(this.styleRef)\n    }\n\n    // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called\n    if (this.imageRef && this.imageRef.complete) {\n      this.onMediaLoad()\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.computeSizes)\n    if (this.containerRef) {\n      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari)\n      this.containerRef.removeEventListener('gesturechange', this.preventZoomSafari)\n    }\n\n    if (this.styleRef) {\n      this.styleRef.parentNode?.removeChild(this.styleRef)\n    }\n\n    this.cleanEvents()\n    this.props.zoomWithScroll && this.clearScrollEvent()\n  }\n\n  componentDidUpdate(prevProps: CropperProps) {\n    if (prevProps.rotation !== this.props.rotation) {\n      this.computeSizes()\n      this.recomputeCropPosition()\n    } else if (prevProps.aspect !== this.props.aspect) {\n      this.computeSizes()\n    } else if (prevProps.zoom !== this.props.zoom) {\n      this.recomputeCropPosition()\n    } else if (\n      prevProps.cropSize?.height !== this.props.cropSize?.height ||\n      prevProps.cropSize?.width !== this.props.cropSize?.width\n    ) {\n      this.computeSizes()\n    } else if (\n      prevProps.crop?.x !== this.props.crop?.x ||\n      prevProps.crop?.y !== this.props.crop?.y\n    ) {\n      this.emitCropAreaChange()\n    }\n    if (prevProps.zoomWithScroll !== this.props.zoomWithScroll && this.containerRef) {\n      this.props.zoomWithScroll\n        ? this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n        : this.clearScrollEvent()\n    }\n    if (prevProps.video !== this.props.video) {\n      this.videoRef?.load()\n    }\n  }\n\n  // this is to prevent Safari on iOS >= 10 to zoom the page\n  preventZoomSafari = (e: Event) => e.preventDefault()\n\n  cleanEvents = () => {\n    document.removeEventListener('mousemove', this.onMouseMove)\n    document.removeEventListener('mouseup', this.onDragStopped)\n    document.removeEventListener('touchmove', this.onTouchMove)\n    document.removeEventListener('touchend', this.onDragStopped)\n  }\n\n  clearScrollEvent = () => {\n    if (this.containerRef) this.containerRef.removeEventListener('wheel', this.onWheel)\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n  }\n\n  onMediaLoad = () => {\n    const cropSize = this.computeSizes()\n\n    if (cropSize) {\n      this.emitCropData()\n      this.setInitialCrop(cropSize)\n    }\n\n    if (this.props.onMediaLoaded) {\n      this.props.onMediaLoaded(this.mediaSize)\n    }\n  }\n\n  setInitialCrop = (cropSize: Size) => {\n    if (this.props.initialCroppedAreaPercentages) {\n      const { crop, zoom } = getInitialCropFromCroppedAreaPercentages(\n        this.props.initialCroppedAreaPercentages,\n        this.mediaSize,\n        this.props.rotation,\n        cropSize,\n        this.props.minZoom,\n        this.props.maxZoom\n      )\n\n      this.props.onCropChange(crop)\n      this.props.onZoomChange && this.props.onZoomChange(zoom)\n    } else if (this.props.initialCroppedAreaPixels) {\n      const { crop, zoom } = getInitialCropFromCroppedAreaPixels(\n        this.props.initialCroppedAreaPixels,\n        this.mediaSize,\n        this.props.rotation,\n        cropSize,\n        this.props.minZoom,\n        this.props.maxZoom\n      )\n\n      this.props.onCropChange(crop)\n      this.props.onZoomChange && this.props.onZoomChange(zoom)\n    }\n  }\n\n  getAspect() {\n    const { cropSize, aspect } = this.props\n    if (cropSize) {\n      return cropSize.width / cropSize.height\n    }\n    return aspect\n  }\n\n  computeSizes = () => {\n    const mediaRef = this.imageRef || this.videoRef\n\n    if (mediaRef && this.containerRef) {\n      this.containerRect = this.containerRef.getBoundingClientRect()\n      const containerAspect = this.containerRect.width / this.containerRect.height\n      const naturalWidth = this.imageRef?.naturalWidth || this.videoRef?.videoWidth || 0\n      const naturalHeight = this.imageRef?.naturalHeight || this.videoRef?.videoHeight || 0\n      const isMediaScaledDown =\n        mediaRef.offsetWidth < naturalWidth || mediaRef.offsetHeight < naturalHeight\n      const mediaAspect = naturalWidth / naturalHeight\n\n      // We do not rely on the offsetWidth/offsetHeight if the media is scaled down\n      // as the values they report are rounded. That will result in precision losses\n      // when calculating zoom. We use the fact that the media is positionned relative\n      // to the container. That allows us to use the container's dimensions\n      // and natural aspect ratio of the media to calculate accurate media size.\n      // However, for this to work, the container should not be rotated\n      let renderedMediaSize: Size\n\n      if (isMediaScaledDown) {\n        switch (this.props.objectFit) {\n          default:\n          case 'contain':\n            renderedMediaSize =\n              containerAspect > mediaAspect\n                ? {\n                    width: this.containerRect.height * mediaAspect,\n                    height: this.containerRect.height,\n                  }\n                : {\n                    width: this.containerRect.width,\n                    height: this.containerRect.width / mediaAspect,\n                  }\n            break\n          case 'horizontal-cover':\n            renderedMediaSize = {\n              width: this.containerRect.width,\n              height: this.containerRect.width / mediaAspect,\n            }\n            break\n          case 'vertical-cover':\n            renderedMediaSize = {\n              width: this.containerRect.height * mediaAspect,\n              height: this.containerRect.height,\n            }\n            break\n          case 'auto-cover':\n            renderedMediaSize =\n              naturalWidth > naturalHeight\n                ? {\n                    width: this.containerRect.width,\n                    height: this.containerRect.width / mediaAspect,\n                  }\n                : {\n                    width: this.containerRect.height * mediaAspect,\n                    height: this.containerRect.height,\n                  }\n            break\n        }\n      } else {\n        renderedMediaSize = {\n          width: mediaRef.offsetWidth,\n          height: mediaRef.offsetHeight,\n        }\n      }\n\n      this.mediaSize = {\n        ...renderedMediaSize,\n        naturalWidth,\n        naturalHeight,\n      }\n\n      const cropSize = this.props.cropSize\n        ? this.props.cropSize\n        : getCropSize(\n            this.mediaSize.width,\n            this.mediaSize.height,\n            this.containerRect.width,\n            this.containerRect.height,\n            this.props.aspect,\n            this.props.rotation\n          )\n\n      if (\n        this.state.cropSize?.height !== cropSize.height ||\n        this.state.cropSize?.width !== cropSize.width\n      ) {\n        this.props.onCropSizeChange && this.props.onCropSizeChange(cropSize)\n      }\n      this.setState({ cropSize }, this.recomputeCropPosition)\n\n      return cropSize\n    }\n  }\n\n  static getMousePoint = (e: MouseEvent | React.MouseEvent) => ({\n    x: Number(e.clientX),\n    y: Number(e.clientY),\n  })\n\n  static getTouchPoint = (touch: Touch | React.Touch) => ({\n    x: Number(touch.clientX),\n    y: Number(touch.clientY),\n  })\n\n  onMouseDown = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    e.preventDefault()\n    document.addEventListener('mousemove', this.onMouseMove)\n    document.addEventListener('mouseup', this.onDragStopped)\n    this.onDragStart(Cropper.getMousePoint(e))\n  }\n\n  onMouseMove = (e: MouseEvent) => this.onDrag(Cropper.getMousePoint(e))\n\n  onTouchStart = (e: React.TouchEvent<HTMLDivElement>) => {\n    if (this.props.onTouchRequest && !this.props.onTouchRequest(e)) {\n      return\n    }\n\n    document.addEventListener('touchmove', this.onTouchMove, { passive: false }) // iOS 11 now defaults to passive: true\n    document.addEventListener('touchend', this.onDragStopped)\n\n    if (e.touches.length === 2) {\n      this.onPinchStart(e)\n    } else if (e.touches.length === 1) {\n      this.onDragStart(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onTouchMove = (e: TouchEvent) => {\n    // Prevent whole page from scrolling on iOS.\n    e.preventDefault()\n    if (e.touches.length === 2) {\n      this.onPinchMove(e)\n    } else if (e.touches.length === 1) {\n      this.onDrag(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onDragStart = ({ x, y }: Point) => {\n    this.dragStartPosition = { x, y }\n    this.dragStartCrop = { ...this.props.crop }\n    this.props.onInteractionStart?.()\n  }\n\n  onDrag = ({ x, y }: Point) => {\n    if (this.rafDragTimeout) window.cancelAnimationFrame(this.rafDragTimeout)\n\n    this.rafDragTimeout = window.requestAnimationFrame(() => {\n      if (!this.state.cropSize) return\n      if (x === undefined || y === undefined) return\n      const offsetX = x - this.dragStartPosition.x\n      const offsetY = y - this.dragStartPosition.y\n      const requestedPosition = {\n        x: this.dragStartCrop.x + offsetX,\n        y: this.dragStartCrop.y + offsetY,\n      }\n\n      const newPosition = this.props.restrictPosition\n        ? restrictPosition(\n            requestedPosition,\n            this.mediaSize,\n            this.state.cropSize,\n            this.props.zoom,\n            this.props.rotation\n          )\n        : requestedPosition\n      this.props.onCropChange(newPosition)\n    })\n  }\n\n  onDragStopped = () => {\n    this.cleanEvents()\n    this.emitCropData()\n    this.props.onInteractionEnd?.()\n  }\n\n  onPinchStart(e: React.TouchEvent<HTMLDivElement>) {\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB)\n    this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB)\n    this.onDragStart(getCenter(pointA, pointB))\n  }\n\n  onPinchMove(e: TouchEvent) {\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    const center = getCenter(pointA, pointB)\n    this.onDrag(center)\n\n    if (this.rafPinchTimeout) window.cancelAnimationFrame(this.rafPinchTimeout)\n    this.rafPinchTimeout = window.requestAnimationFrame(() => {\n      const distance = getDistanceBetweenPoints(pointA, pointB)\n      const newZoom = this.props.zoom * (distance / this.lastPinchDistance)\n      this.setNewZoom(newZoom, center)\n      this.lastPinchDistance = distance\n\n      const rotation = getRotationBetweenPoints(pointA, pointB)\n      const newRotation = this.props.rotation + (rotation - this.lastPinchRotation)\n      this.props.onRotationChange && this.props.onRotationChange(newRotation)\n      this.lastPinchRotation = rotation\n    })\n  }\n\n  onWheel = (e: WheelEvent) => {\n    if (this.props.onWheelRequest && !this.props.onWheelRequest(e)) {\n      return\n    }\n\n    e.preventDefault()\n    const point = Cropper.getMousePoint(e)\n    const { pixelY } = normalizeWheel(e)\n    const newZoom = this.props.zoom - (pixelY * this.props.zoomSpeed) / 200\n    this.setNewZoom(newZoom, point)\n\n    if (!this.state.hasWheelJustStarted) {\n      this.setState({ hasWheelJustStarted: true }, () => this.props.onInteractionStart?.())\n    }\n\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n    this.wheelTimer = window.setTimeout(\n      () => this.setState({ hasWheelJustStarted: false }, () => this.props.onInteractionEnd?.()),\n      250\n    )\n  }\n\n  getPointOnContainer = ({ x, y }: Point) => {\n    if (!this.containerRect) {\n      throw new Error('The Cropper is not mounted')\n    }\n    return {\n      x: this.containerRect.width / 2 - (x - this.containerRect.left),\n      y: this.containerRect.height / 2 - (y - this.containerRect.top),\n    }\n  }\n\n  getPointOnMedia = ({ x, y }: Point) => {\n    const { crop, zoom } = this.props\n    return {\n      x: (x + crop.x) / zoom,\n      y: (y + crop.y) / zoom,\n    }\n  }\n\n  setNewZoom = (zoom: number, point: Point) => {\n    if (!this.state.cropSize || !this.props.onZoomChange) return\n\n    const zoomPoint = this.getPointOnContainer(point)\n    const zoomTarget = this.getPointOnMedia(zoomPoint)\n    const newZoom = clamp(zoom, this.props.minZoom, this.props.maxZoom)\n    const requestedPosition = {\n      x: zoomTarget.x * newZoom - zoomPoint.x,\n      y: zoomTarget.y * newZoom - zoomPoint.y,\n    }\n    const newPosition = this.props.restrictPosition\n      ? restrictPosition(\n          requestedPosition,\n          this.mediaSize,\n          this.state.cropSize,\n          newZoom,\n          this.props.rotation\n        )\n      : requestedPosition\n\n    this.props.onCropChange(newPosition)\n    this.props.onZoomChange(newZoom)\n  }\n\n  getCropData = () => {\n    if (!this.state.cropSize) {\n      return null\n    }\n\n    // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ValentinH/react-easy-crop/issues/6)\n    const restrictedPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n    return computeCroppedArea(\n      restrictedPosition,\n      this.mediaSize,\n      this.state.cropSize,\n      this.getAspect(),\n      this.props.zoom,\n      this.props.rotation,\n      this.props.restrictPosition\n    )\n  }\n\n  emitCropData = () => {\n    const cropData = this.getCropData()\n    if (!cropData) return\n\n    const { croppedAreaPercentages, croppedAreaPixels } = cropData\n    if (this.props.onCropComplete) {\n      this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels)\n    }\n\n    if (this.props.onCropAreaChange) {\n      this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels)\n    }\n  }\n\n  emitCropAreaChange = () => {\n    const cropData = this.getCropData()\n    if (!cropData) return\n\n    const { croppedAreaPercentages, croppedAreaPixels } = cropData\n    if (this.props.onCropAreaChange) {\n      this.props.onCropAreaChange(croppedAreaPercentages, croppedAreaPixels)\n    }\n  }\n\n  recomputeCropPosition = () => {\n    if (!this.state.cropSize) return\n\n    const newPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n\n    this.props.onCropChange(newPosition)\n    this.emitCropData()\n  }\n\n  render() {\n    const {\n      image,\n      video,\n      mediaProps,\n      transform,\n      crop: { x, y },\n      rotation,\n      zoom,\n      cropShape,\n      showGrid,\n      style: { containerStyle, cropAreaStyle, mediaStyle },\n      classes: { containerClassName, cropAreaClassName, mediaClassName },\n      objectFit,\n    } = this.props\n\n    return (\n      <div\n        onMouseDown={this.onMouseDown}\n        onTouchStart={this.onTouchStart}\n        ref={(el) => (this.containerRef = el)}\n        data-testid=\"container\"\n        style={containerStyle}\n        className={classNames('reactEasyCrop_Container', containerClassName)}\n      >\n        {image ? (\n          <img\n            alt=\"\"\n            className={classNames(\n              'reactEasyCrop_Image',\n              objectFit === 'contain' && 'reactEasyCrop_Contain',\n              objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal',\n              objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical',\n              objectFit === 'auto-cover' &&\n                (this.mediaSize.naturalWidth > this.mediaSize.naturalHeight\n                  ? 'reactEasyCrop_Cover_Horizontal'\n                  : 'reactEasyCrop_Cover_Vertical'),\n              mediaClassName\n            )}\n            {...(mediaProps as React.ImgHTMLAttributes<HTMLElement>)}\n            src={image}\n            ref={(el: HTMLImageElement) => (this.imageRef = el)}\n            style={{\n              ...mediaStyle,\n              transform:\n                transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n            }}\n            onLoad={this.onMediaLoad}\n          />\n        ) : (\n          video && (\n            <video\n              autoPlay\n              loop\n              muted={true}\n              className={classNames(\n                'reactEasyCrop_Video',\n                objectFit === 'contain' && 'reactEasyCrop_Contain',\n                objectFit === 'horizontal-cover' && 'reactEasyCrop_Cover_Horizontal',\n                objectFit === 'vertical-cover' && 'reactEasyCrop_Cover_Vertical',\n                objectFit === 'auto-cover' &&\n                  (this.mediaSize.naturalWidth > this.mediaSize.naturalHeight\n                    ? 'reactEasyCrop_Cover_Horizontal'\n                    : 'reactEasyCrop_Cover_Vertical'),\n                mediaClassName\n              )}\n              {...mediaProps}\n              ref={(el: HTMLVideoElement) => (this.videoRef = el)}\n              onLoadedMetadata={this.onMediaLoad}\n              style={{\n                ...mediaStyle,\n                transform:\n                  transform || `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n              }}\n              controls={false}\n            >\n              {(Array.isArray(video) ? video : [{ src: video }]).map((item) => (\n                <source key={item.src} {...item} />\n              ))}\n            </video>\n          )\n        )}\n        {this.state.cropSize && (\n          <div\n            style={{\n              ...cropAreaStyle,\n              width: this.state.cropSize.width,\n              height: this.state.cropSize.height,\n            }}\n            data-testid=\"cropper\"\n            className={classNames(\n              'reactEasyCrop_CropArea',\n              cropShape === 'round' && 'reactEasyCrop_CropAreaRound',\n              showGrid && 'reactEasyCrop_CropAreaGrid',\n              cropAreaClassName\n            )}\n          />\n        )}\n      </div>\n    )\n  }\n}\n\nexport default Cropper\n"]},"metadata":{},"sourceType":"module"}