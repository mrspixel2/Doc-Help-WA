{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _toArray from \"@babel/runtime/helpers/esm/toArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport warning from \"rc-util/es/warning\";\nimport { toArray } from './commonUtil';\n\nfunction getKey(data, index) {\n  var key = data.key;\n  var value;\n\n  if ('value' in data) {\n    value = data.value;\n  }\n\n  if (key !== null && key !== undefined) {\n    return key;\n  }\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  return \"rc-index-key-\".concat(index);\n}\n/**\n * Flat options into flatten list.\n * We use `optionOnly` here is aim to avoid user use nested option group.\n * Here is simply set `key` to the index if not provided.\n */\n\n\nexport function flattenOptions(options) {\n  var flattenList = [];\n\n  function dig(list, isGroupOption) {\n    list.forEach(function (data) {\n      if (isGroupOption || !('options' in data)) {\n        // Option\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          groupOption: isGroupOption,\n          data: data\n        });\n      } else {\n        // Option Group\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          group: true,\n          data: data\n        });\n        dig(data.options, true);\n      }\n    });\n  }\n\n  dig(options, false);\n  return flattenList;\n}\n/**\n * Inject `props` into `option` for legacy usage\n */\n\nfunction injectPropsWithOption(option) {\n  var newOption = _objectSpread({}, option);\n\n  if (!('props' in newOption)) {\n    Object.defineProperty(newOption, 'props', {\n      get: function get() {\n        warning(false, 'Return type is option instead of Option instance. Please read value directly instead of reading from `props`.');\n        return newOption;\n      }\n    });\n  }\n\n  return newOption;\n}\n\nexport function findValueOption(values, options) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref$prevValueOptions = _ref.prevValueOptions,\n      prevValueOptions = _ref$prevValueOptions === void 0 ? [] : _ref$prevValueOptions;\n\n  var optionMap = new Map();\n  options.forEach(function (flattenItem) {\n    if (!flattenItem.group) {\n      var data = flattenItem.data; // Check if match\n\n      optionMap.set(data.value, data);\n    }\n  });\n  return values.map(function (val) {\n    var option = optionMap.get(val); // Fallback to try to find prev options\n\n    if (!option) {\n      option = _objectSpread({}, prevValueOptions.find(function (opt) {\n        return opt._INTERNAL_OPTION_VALUE_ === val;\n      }));\n    }\n\n    return injectPropsWithOption(option);\n  });\n}\nexport var getLabeledValue = function getLabeledValue(value, _ref2) {\n  var options = _ref2.options,\n      prevValue = _ref2.prevValue,\n      labelInValue = _ref2.labelInValue,\n      optionLabelProp = _ref2.optionLabelProp;\n  var item = findValueOption([value], options)[0];\n  var result = {\n    value: value\n  };\n  var prevValItem;\n  var prevValues = toArray(prevValue);\n\n  if (labelInValue) {\n    prevValItem = prevValues.find(function (prevItem) {\n      if (_typeof(prevItem) === 'object' && 'value' in prevItem) {\n        return prevItem.value === value;\n      } // [Legacy] Support `key` as `value`\n\n\n      return prevItem.key === value;\n    });\n  }\n\n  if (prevValItem && _typeof(prevValItem) === 'object' && 'label' in prevValItem) {\n    result.label = prevValItem.label;\n\n    if (item && typeof prevValItem.label === 'string' && typeof item[optionLabelProp] === 'string' && prevValItem.label.trim() !== item[optionLabelProp].trim()) {\n      warning(false, '`label` of `value` is not same as `label` in Select options.');\n    }\n  } else if (item && optionLabelProp in item) {\n    result.label = item[optionLabelProp];\n  } else {\n    result.label = value;\n  } // Used for motion control\n\n\n  result.key = result.value;\n  return result;\n};\n\nfunction toRawString(content) {\n  return toArray(content).join('');\n}\n/** Filter single option if match the search text */\n\n\nfunction getFilterFunction(optionFilterProp) {\n  return function (searchValue, option) {\n    var lowerSearchText = searchValue.toLowerCase(); // Group label search\n\n    if ('options' in option) {\n      return toRawString(option.label).toLowerCase().includes(lowerSearchText);\n    } // Option value search\n\n\n    var rawValue = option[optionFilterProp];\n    var value = toRawString(rawValue).toLowerCase();\n    return value.includes(lowerSearchText);\n  };\n}\n/** Filter options and return a new options by the search text */\n\n\nexport function filterOptions(searchValue, options, _ref3) {\n  var optionFilterProp = _ref3.optionFilterProp,\n      filterOption = _ref3.filterOption;\n  var filteredOptions = [];\n  var filterFunc;\n\n  if (filterOption === false) {\n    return _toConsumableArray(options);\n  }\n\n  if (typeof filterOption === 'function') {\n    filterFunc = filterOption;\n  } else {\n    filterFunc = getFilterFunction(optionFilterProp);\n  }\n\n  options.forEach(function (item) {\n    // Group should check child options\n    if ('options' in item) {\n      // Check group first\n      var matchGroup = filterFunc(searchValue, item);\n\n      if (matchGroup) {\n        filteredOptions.push(item);\n      } else {\n        // Check option\n        var subOptions = item.options.filter(function (subItem) {\n          return filterFunc(searchValue, subItem);\n        });\n\n        if (subOptions.length) {\n          filteredOptions.push(_objectSpread(_objectSpread({}, item), {}, {\n            options: subOptions\n          }));\n        }\n      }\n\n      return;\n    }\n\n    if (filterFunc(searchValue, injectPropsWithOption(item))) {\n      filteredOptions.push(item);\n    }\n  });\n  return filteredOptions;\n}\nexport function getSeparatedContent(text, tokens) {\n  if (!tokens || !tokens.length) {\n    return null;\n  }\n\n  var match = false;\n\n  function separate(str, _ref4) {\n    var _ref5 = _toArray(_ref4),\n        token = _ref5[0],\n        restTokens = _ref5.slice(1);\n\n    if (!token) {\n      return [str];\n    }\n\n    var list = str.split(token);\n    match = match || list.length > 1;\n    return list.reduce(function (prevList, unitStr) {\n      return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));\n    }, []).filter(function (unit) {\n      return unit;\n    });\n  }\n\n  var list = separate(text, tokens);\n  return match ? list : null;\n}\nexport function isValueDisabled(value, options) {\n  var option = findValueOption([value], options)[0];\n  return option.disabled;\n}\n/**\n * `tags` mode should fill un-list item into the option list\n */\n\nexport function fillOptionsWithMissingValue(options, value, optionLabelProp, labelInValue) {\n  var values = toArray(value).slice().sort();\n\n  var cloneOptions = _toConsumableArray(options); // Convert options value to set\n\n\n  var optionValues = new Set();\n  options.forEach(function (opt) {\n    if (opt.options) {\n      opt.options.forEach(function (subOpt) {\n        optionValues.add(subOpt.value);\n      });\n    } else {\n      optionValues.add(opt.value);\n    }\n  }); // Fill missing value\n\n  values.forEach(function (item) {\n    var val = labelInValue ? item.value : item;\n\n    if (!optionValues.has(val)) {\n      var _ref6;\n\n      cloneOptions.push(labelInValue ? (_ref6 = {}, _defineProperty(_ref6, optionLabelProp, item.label), _defineProperty(_ref6, \"value\", val), _ref6) : {\n        value: val\n      });\n    }\n  });\n  return cloneOptions;\n}","map":{"version":3,"names":["_defineProperty","_toArray","_toConsumableArray","_typeof","_objectSpread","warning","toArray","getKey","data","index","key","value","undefined","concat","flattenOptions","options","flattenList","dig","list","isGroupOption","forEach","push","length","groupOption","group","injectPropsWithOption","option","newOption","Object","defineProperty","get","findValueOption","values","_ref","arguments","_ref$prevValueOptions","prevValueOptions","optionMap","Map","flattenItem","set","map","val","find","opt","_INTERNAL_OPTION_VALUE_","getLabeledValue","_ref2","prevValue","labelInValue","optionLabelProp","item","result","prevValItem","prevValues","prevItem","label","trim","toRawString","content","join","getFilterFunction","optionFilterProp","searchValue","lowerSearchText","toLowerCase","includes","rawValue","filterOptions","_ref3","filterOption","filteredOptions","filterFunc","matchGroup","subOptions","filter","subItem","getSeparatedContent","text","tokens","match","separate","str","_ref4","_ref5","token","restTokens","slice","split","reduce","prevList","unitStr","unit","isValueDisabled","disabled","fillOptionsWithMissingValue","sort","cloneOptions","optionValues","Set","subOpt","add","has","_ref6"],"sources":["E:/Work/PFE/Project folder/DocHelp/node_modules/rc-select/es/utils/valueUtil.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _toArray from \"@babel/runtime/helpers/esm/toArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport warning from \"rc-util/es/warning\";\nimport { toArray } from './commonUtil';\n\nfunction getKey(data, index) {\n  var key = data.key;\n  var value;\n\n  if ('value' in data) {\n    value = data.value;\n  }\n\n  if (key !== null && key !== undefined) {\n    return key;\n  }\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  return \"rc-index-key-\".concat(index);\n}\n/**\n * Flat options into flatten list.\n * We use `optionOnly` here is aim to avoid user use nested option group.\n * Here is simply set `key` to the index if not provided.\n */\n\n\nexport function flattenOptions(options) {\n  var flattenList = [];\n\n  function dig(list, isGroupOption) {\n    list.forEach(function (data) {\n      if (isGroupOption || !('options' in data)) {\n        // Option\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          groupOption: isGroupOption,\n          data: data\n        });\n      } else {\n        // Option Group\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          group: true,\n          data: data\n        });\n        dig(data.options, true);\n      }\n    });\n  }\n\n  dig(options, false);\n  return flattenList;\n}\n/**\n * Inject `props` into `option` for legacy usage\n */\n\nfunction injectPropsWithOption(option) {\n  var newOption = _objectSpread({}, option);\n\n  if (!('props' in newOption)) {\n    Object.defineProperty(newOption, 'props', {\n      get: function get() {\n        warning(false, 'Return type is option instead of Option instance. Please read value directly instead of reading from `props`.');\n        return newOption;\n      }\n    });\n  }\n\n  return newOption;\n}\n\nexport function findValueOption(values, options) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref$prevValueOptions = _ref.prevValueOptions,\n      prevValueOptions = _ref$prevValueOptions === void 0 ? [] : _ref$prevValueOptions;\n\n  var optionMap = new Map();\n  options.forEach(function (flattenItem) {\n    if (!flattenItem.group) {\n      var data = flattenItem.data; // Check if match\n\n      optionMap.set(data.value, data);\n    }\n  });\n  return values.map(function (val) {\n    var option = optionMap.get(val); // Fallback to try to find prev options\n\n    if (!option) {\n      option = _objectSpread({}, prevValueOptions.find(function (opt) {\n        return opt._INTERNAL_OPTION_VALUE_ === val;\n      }));\n    }\n\n    return injectPropsWithOption(option);\n  });\n}\nexport var getLabeledValue = function getLabeledValue(value, _ref2) {\n  var options = _ref2.options,\n      prevValue = _ref2.prevValue,\n      labelInValue = _ref2.labelInValue,\n      optionLabelProp = _ref2.optionLabelProp;\n  var item = findValueOption([value], options)[0];\n  var result = {\n    value: value\n  };\n  var prevValItem;\n  var prevValues = toArray(prevValue);\n\n  if (labelInValue) {\n    prevValItem = prevValues.find(function (prevItem) {\n      if (_typeof(prevItem) === 'object' && 'value' in prevItem) {\n        return prevItem.value === value;\n      } // [Legacy] Support `key` as `value`\n\n\n      return prevItem.key === value;\n    });\n  }\n\n  if (prevValItem && _typeof(prevValItem) === 'object' && 'label' in prevValItem) {\n    result.label = prevValItem.label;\n\n    if (item && typeof prevValItem.label === 'string' && typeof item[optionLabelProp] === 'string' && prevValItem.label.trim() !== item[optionLabelProp].trim()) {\n      warning(false, '`label` of `value` is not same as `label` in Select options.');\n    }\n  } else if (item && optionLabelProp in item) {\n    result.label = item[optionLabelProp];\n  } else {\n    result.label = value;\n  } // Used for motion control\n\n\n  result.key = result.value;\n  return result;\n};\n\nfunction toRawString(content) {\n  return toArray(content).join('');\n}\n/** Filter single option if match the search text */\n\n\nfunction getFilterFunction(optionFilterProp) {\n  return function (searchValue, option) {\n    var lowerSearchText = searchValue.toLowerCase(); // Group label search\n\n    if ('options' in option) {\n      return toRawString(option.label).toLowerCase().includes(lowerSearchText);\n    } // Option value search\n\n\n    var rawValue = option[optionFilterProp];\n    var value = toRawString(rawValue).toLowerCase();\n    return value.includes(lowerSearchText);\n  };\n}\n/** Filter options and return a new options by the search text */\n\n\nexport function filterOptions(searchValue, options, _ref3) {\n  var optionFilterProp = _ref3.optionFilterProp,\n      filterOption = _ref3.filterOption;\n  var filteredOptions = [];\n  var filterFunc;\n\n  if (filterOption === false) {\n    return _toConsumableArray(options);\n  }\n\n  if (typeof filterOption === 'function') {\n    filterFunc = filterOption;\n  } else {\n    filterFunc = getFilterFunction(optionFilterProp);\n  }\n\n  options.forEach(function (item) {\n    // Group should check child options\n    if ('options' in item) {\n      // Check group first\n      var matchGroup = filterFunc(searchValue, item);\n\n      if (matchGroup) {\n        filteredOptions.push(item);\n      } else {\n        // Check option\n        var subOptions = item.options.filter(function (subItem) {\n          return filterFunc(searchValue, subItem);\n        });\n\n        if (subOptions.length) {\n          filteredOptions.push(_objectSpread(_objectSpread({}, item), {}, {\n            options: subOptions\n          }));\n        }\n      }\n\n      return;\n    }\n\n    if (filterFunc(searchValue, injectPropsWithOption(item))) {\n      filteredOptions.push(item);\n    }\n  });\n  return filteredOptions;\n}\nexport function getSeparatedContent(text, tokens) {\n  if (!tokens || !tokens.length) {\n    return null;\n  }\n\n  var match = false;\n\n  function separate(str, _ref4) {\n    var _ref5 = _toArray(_ref4),\n        token = _ref5[0],\n        restTokens = _ref5.slice(1);\n\n    if (!token) {\n      return [str];\n    }\n\n    var list = str.split(token);\n    match = match || list.length > 1;\n    return list.reduce(function (prevList, unitStr) {\n      return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));\n    }, []).filter(function (unit) {\n      return unit;\n    });\n  }\n\n  var list = separate(text, tokens);\n  return match ? list : null;\n}\nexport function isValueDisabled(value, options) {\n  var option = findValueOption([value], options)[0];\n  return option.disabled;\n}\n/**\n * `tags` mode should fill un-list item into the option list\n */\n\nexport function fillOptionsWithMissingValue(options, value, optionLabelProp, labelInValue) {\n  var values = toArray(value).slice().sort();\n\n  var cloneOptions = _toConsumableArray(options); // Convert options value to set\n\n\n  var optionValues = new Set();\n  options.forEach(function (opt) {\n    if (opt.options) {\n      opt.options.forEach(function (subOpt) {\n        optionValues.add(subOpt.value);\n      });\n    } else {\n      optionValues.add(opt.value);\n    }\n  }); // Fill missing value\n\n  values.forEach(function (item) {\n    var val = labelInValue ? item.value : item;\n\n    if (!optionValues.has(val)) {\n      var _ref6;\n\n      cloneOptions.push(labelInValue ? (_ref6 = {}, _defineProperty(_ref6, optionLabelProp, item.label), _defineProperty(_ref6, \"value\", val), _ref6) : {\n        value: val\n      });\n    }\n  });\n  return cloneOptions;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}