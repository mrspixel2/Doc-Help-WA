{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nimport * as React from 'react';\nimport classNames from 'classnames';\nimport raf from 'raf';\nimport Filler from './Filler';\nimport { getElementScrollPercentage, getScrollPercentage, getNodeHeight, getRangeIndex, getItemAbsoluteTop, GHOST_ITEM_KEY, getItemRelativeTop, getCompareItemRelativeTop, alignScrollTop, requireVirtual } from './utils/itemUtil';\nimport { getIndexByStartLoc, findListDiffIndex } from './utils/algorithmUtil';\nvar ScrollStyle = {\n  overflowY: 'auto',\n  overflowAnchor: 'none'\n};\nvar ITEM_SCALE_RATE = 1;\n/**\n * We use class component here since typescript can not support generic in function component\n *\n * Virtual list display logic:\n * 1. scroll / initialize trigger measure\n * 2. Get location item of current `scrollTop`\n * 3. [Render] Render visible items\n * 4. Get all the visible items height\n * 5. [Render] Update top item `margin-top` to fit the position\n *\n * Algorithm:\n * We split scroll bar into equal slice. An item with whatever height occupy the same range slice.\n * When `scrollTop` change,\n * it will calculate the item percentage position and move item to the position.\n * Then calculate other item position base on the located item.\n *\n * Concept:\n *\n * # located item\n * The base position item which other items position calculate base on.\n */\n\nvar List =\n/** @class */\nfunction () {\n  var List = /*#__PURE__*/function (_React$Component) {\n    _inherits(List, _React$Component);\n\n    var _super = _createSuper(List);\n\n    function List(props) {\n      var _this;\n\n      _classCallCheck(this, List);\n\n      _this = _super.call(this, props);\n      _this.listRef = React.createRef();\n      _this.itemElements = {};\n      _this.itemElementHeights = {};\n      /**\n       * Lock scroll process with `onScroll` event.\n       * This is used for `data` length change and `scrollTop` restore\n       */\n\n      _this.lockScroll = false;\n      /**\n       * Phase 2: Trigger render since we should re-calculate current position.\n       */\n\n      _this.onScroll = function (event) {\n        var _this$props = _this.props,\n            data = _this$props.data,\n            height = _this$props.height,\n            itemHeight = _this$props.itemHeight,\n            disabled = _this$props.disabled;\n        var _this$listRef$current = _this.listRef.current,\n            originScrollTop = _this$listRef$current.scrollTop,\n            clientHeight = _this$listRef$current.clientHeight,\n            scrollHeight = _this$listRef$current.scrollHeight;\n        var scrollTop = alignScrollTop(originScrollTop, scrollHeight - clientHeight); // Skip if `scrollTop` not change to avoid shake\n\n        if (scrollTop === _this.state.scrollTop || _this.lockScroll || disabled) {\n          return;\n        }\n\n        var scrollPtg = getElementScrollPercentage(_this.listRef.current);\n        var visibleCount = Math.ceil(height / itemHeight);\n\n        var _getRangeIndex = getRangeIndex(scrollPtg, data.length, visibleCount),\n            itemIndex = _getRangeIndex.itemIndex,\n            itemOffsetPtg = _getRangeIndex.itemOffsetPtg,\n            startIndex = _getRangeIndex.startIndex,\n            endIndex = _getRangeIndex.endIndex;\n\n        _this.setState({\n          status: 'MEASURE_START',\n          scrollTop: scrollTop,\n          itemIndex: itemIndex,\n          itemOffsetPtg: itemOffsetPtg,\n          startIndex: startIndex,\n          endIndex: endIndex\n        });\n\n        _this.triggerOnScroll(event);\n      };\n\n      _this.onRawScroll = function (event) {\n        var scrollTop = _this.listRef.current.scrollTop;\n\n        _this.setState({\n          scrollTop: scrollTop\n        });\n\n        _this.triggerOnScroll(event);\n      };\n\n      _this.triggerOnScroll = function (event) {\n        var onScroll = _this.props.onScroll;\n\n        if (onScroll && event) {\n          onScroll(event);\n        }\n      };\n\n      _this.getIndexKey = function (index, props) {\n        var mergedProps = props || _this.props;\n        var _mergedProps$data = mergedProps.data,\n            data = _mergedProps$data === void 0 ? [] : _mergedProps$data; // Return ghost key as latest index item\n\n        if (index === data.length) {\n          return GHOST_ITEM_KEY;\n        }\n\n        var item = data[index];\n        /* istanbul ignore next */\n\n        if (item === undefined) {\n          console.error('Not find index item. Please report this since it is a bug.');\n          return null;\n        }\n\n        return _this.getItemKey(item, mergedProps);\n      };\n\n      _this.getItemKey = function (item, props) {\n        var _ref = props || _this.props,\n            itemKey = _ref.itemKey;\n\n        return typeof itemKey === 'function' ? itemKey(item) : item[itemKey];\n      };\n      /**\n       * Collect current rendered dom element item heights\n       */\n\n\n      _this.collectItemHeights = function (range) {\n        var _ref2 = range || _this.state,\n            startIndex = _ref2.startIndex,\n            endIndex = _ref2.endIndex;\n\n        var data = _this.props.data; // Record here since measure item height will get warning in `render`\n\n        for (var index = startIndex; index <= endIndex; index += 1) {\n          var item = data[index]; // Only collect exist item height\n\n          if (item) {\n            var eleKey = _this.getItemKey(item);\n\n            _this.itemElementHeights[eleKey] = getNodeHeight(_this.itemElements[eleKey]);\n          }\n        }\n      };\n\n      _this.scrollTo = function (arg0) {\n        raf.cancel(_this.rafId);\n        _this.rafId = raf(function () {\n          // Number top\n          if (_typeof(arg0) === 'object') {\n            var isVirtual = _this.state.isVirtual;\n            var _this$props2 = _this.props,\n                height = _this$props2.height,\n                itemHeight = _this$props2.itemHeight,\n                data = _this$props2.data;\n            var _arg0$align = arg0.align,\n                align = _arg0$align === void 0 ? 'auto' : _arg0$align;\n            var index = 0;\n\n            if ('index' in arg0) {\n              index = arg0.index;\n            } else if ('key' in arg0) {\n              var key = arg0.key;\n              index = data.findIndex(function (item) {\n                return _this.getItemKey(item) === key;\n              });\n            }\n\n            var visibleCount = Math.ceil(height / itemHeight);\n            var item = data[index];\n\n            if (item) {\n              var clientHeight = _this.listRef.current.clientHeight;\n\n              if (isVirtual) {\n                // Calculate related data\n                var _this$state = _this.state,\n                    itemIndex = _this$state.itemIndex,\n                    itemOffsetPtg = _this$state.itemOffsetPtg;\n                var scrollTop = _this.listRef.current.scrollTop;\n                var scrollPtg = getElementScrollPercentage(_this.listRef.current);\n                var relativeLocatedItemTop = getItemRelativeTop({\n                  itemIndex: itemIndex,\n                  itemOffsetPtg: itemOffsetPtg,\n                  itemElementHeights: _this.itemElementHeights,\n                  scrollPtg: scrollPtg,\n                  clientHeight: clientHeight,\n                  getItemKey: _this.getIndexKey\n                }); // We will force render related items to collect height for re-location\n\n                _this.setState({\n                  startIndex: Math.max(0, index - visibleCount),\n                  endIndex: Math.min(data.length - 1, index + visibleCount)\n                }, function () {\n                  _this.collectItemHeights(); // Calculate related top\n\n\n                  var relativeTop;\n                  var mergedAlgin = align;\n\n                  if (align === 'auto') {\n                    var shouldChange = true; // Check if exist in the visible range\n\n                    if (Math.abs(itemIndex - index) < visibleCount) {\n                      var itemTop = relativeLocatedItemTop;\n\n                      if (index < itemIndex) {\n                        for (var i = index; i < itemIndex; i += 1) {\n                          var eleKey = _this.getIndexKey(i);\n\n                          itemTop -= _this.itemElementHeights[eleKey] || 0;\n                        }\n                      } else {\n                        for (var _i = itemIndex; _i <= index; _i += 1) {\n                          var _eleKey = _this.getIndexKey(_i);\n\n                          itemTop += _this.itemElementHeights[_eleKey] || 0;\n                        }\n                      }\n\n                      shouldChange = itemTop <= 0 || itemTop >= clientHeight;\n                    }\n\n                    if (shouldChange) {\n                      // Out of range will fall back to position align\n                      mergedAlgin = index < itemIndex ? 'top' : 'bottom';\n                    } else {\n                      var _getRangeIndex2 = getRangeIndex(scrollPtg, data.length, visibleCount),\n                          nextIndex = _getRangeIndex2.itemIndex,\n                          newOffsetPtg = _getRangeIndex2.itemOffsetPtg,\n                          startIndex = _getRangeIndex2.startIndex,\n                          endIndex = _getRangeIndex2.endIndex;\n\n                      _this.setState({\n                        scrollTop: scrollTop,\n                        itemIndex: nextIndex,\n                        itemOffsetPtg: newOffsetPtg,\n                        startIndex: startIndex,\n                        endIndex: endIndex\n                      });\n\n                      return;\n                    }\n                  } // Align with position should make scroll happen\n\n\n                  if (mergedAlgin === 'top') {\n                    relativeTop = 0;\n                  } else if (mergedAlgin === 'bottom') {\n                    var _eleKey2 = _this.getItemKey(item);\n\n                    relativeTop = clientHeight - _this.itemElementHeights[_eleKey2] || 0;\n                  }\n\n                  _this.internalScrollTo({\n                    itemIndex: index,\n                    relativeTop: relativeTop\n                  });\n                });\n              } else {\n                // Raw list without virtual scroll set position directly\n                _this.collectItemHeights({\n                  startIndex: 0,\n                  endIndex: data.length - 1\n                });\n\n                var mergedAlgin = align; // Collection index item position\n\n                var indexItemHeight = _this.itemElementHeights[_this.getIndexKey(index)];\n\n                var itemTop = 0;\n\n                for (var i = 0; i < index; i += 1) {\n                  var eleKey = _this.getIndexKey(i);\n\n                  itemTop += _this.itemElementHeights[eleKey] || 0;\n                }\n\n                var itemBottom = itemTop + indexItemHeight;\n\n                if (mergedAlgin === 'auto') {\n                  if (itemTop < _this.listRef.current.scrollTop) {\n                    mergedAlgin = 'top';\n                  } else if (itemBottom > _this.listRef.current.scrollTop + clientHeight) {\n                    mergedAlgin = 'bottom';\n                  }\n                }\n\n                if (mergedAlgin === 'top') {\n                  _this.listRef.current.scrollTop = itemTop;\n                } else if (mergedAlgin === 'bottom') {\n                  _this.listRef.current.scrollTop = itemTop - (clientHeight - indexItemHeight);\n                }\n              }\n            }\n          } else {\n            _this.listRef.current.scrollTop = arg0;\n          }\n        });\n      };\n      /**\n       * Phase 4: Render item and get all the visible items height\n       */\n\n\n      _this.renderChildren = function (list, startIndex, renderFunc) {\n        var status = _this.state.status; // We should measure rendered item height\n\n        return list.map(function (item, index) {\n          var eleIndex = startIndex + index;\n          var node = renderFunc(item, eleIndex, {\n            style: status === 'MEASURE_START' ? {\n              visibility: 'hidden'\n            } : {}\n          });\n\n          var eleKey = _this.getIndexKey(eleIndex); // Pass `key` and `ref` for internal measure\n\n\n          return React.cloneElement(node, {\n            key: eleKey,\n            ref: function ref(ele) {\n              _this.itemElements[eleKey] = ele;\n            }\n          });\n        });\n      };\n\n      _this.cachedProps = props;\n      _this.state = {\n        status: 'NONE',\n        scrollTop: null,\n        itemIndex: 0,\n        itemOffsetPtg: 0,\n        startIndex: 0,\n        endIndex: 0,\n        startItemTop: 0,\n        isVirtual: requireVirtual(props.height, props.itemHeight, props.data.length, props.virtual),\n        itemCount: props.data.length\n      };\n      return _this;\n    }\n\n    _createClass(List, [{\n      key: \"componentDidMount\",\n\n      /**\n       * Phase 1: Initial should sync with default scroll top\n       */\n      value: function componentDidMount() {\n        if (this.listRef.current) {\n          this.listRef.current.scrollTop = 0;\n          this.onScroll(null);\n        }\n      }\n      /**\n       * Phase 4: Record used item height\n       * Phase 5: Trigger re-render to use correct position\n       */\n\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate() {\n        var _this2 = this;\n\n        var status = this.state.status;\n        var _this$props3 = this.props,\n            data = _this$props3.data,\n            height = _this$props3.height,\n            itemHeight = _this$props3.itemHeight,\n            disabled = _this$props3.disabled,\n            onSkipRender = _this$props3.onSkipRender,\n            virtual = _this$props3.virtual;\n        var prevData = this.cachedProps.data || [];\n        var changedItemIndex = null;\n\n        if (prevData.length !== data.length) {\n          var diff = findListDiffIndex(prevData, data, this.getItemKey);\n          changedItemIndex = diff ? diff.index : null;\n        }\n\n        if (disabled) {\n          // Should trigger `onSkipRender` to tell that diff component is not render in the list\n          if (data.length > prevData.length) {\n            var _this$state2 = this.state,\n                startIndex = _this$state2.startIndex,\n                endIndex = _this$state2.endIndex;\n\n            if (onSkipRender && (changedItemIndex === null || changedItemIndex < startIndex || endIndex < changedItemIndex)) {\n              onSkipRender();\n            }\n          }\n\n          return;\n        }\n\n        var isVirtual = requireVirtual(height, itemHeight, data.length, virtual);\n        var nextStatus = status;\n\n        if (this.state.isVirtual !== isVirtual) {\n          nextStatus = isVirtual ? 'SWITCH_TO_VIRTUAL' : 'SWITCH_TO_RAW';\n          this.setState({\n            isVirtual: isVirtual,\n            status: nextStatus\n          });\n          /**\n           * We will wait a tick to let list turn to virtual list.\n           * And then use virtual list sync logic to adjust the scroll.\n           */\n\n          if (nextStatus === 'SWITCH_TO_VIRTUAL') {\n            return;\n          }\n        }\n\n        if (status === 'MEASURE_START') {\n          var _this$state3 = this.state,\n              _startIndex = _this$state3.startIndex,\n              itemIndex = _this$state3.itemIndex,\n              itemOffsetPtg = _this$state3.itemOffsetPtg;\n          var scrollTop = this.listRef.current.scrollTop; // Record here since measure item height will get warning in `render`\n\n          this.collectItemHeights(); // Calculate top visible item top offset\n\n          var locatedItemTop = getItemAbsoluteTop({\n            itemIndex: itemIndex,\n            itemOffsetPtg: itemOffsetPtg,\n            itemElementHeights: this.itemElementHeights,\n            scrollTop: scrollTop,\n            scrollPtg: getElementScrollPercentage(this.listRef.current),\n            clientHeight: this.listRef.current.clientHeight,\n            getItemKey: this.getIndexKey\n          });\n          var startItemTop = locatedItemTop;\n\n          for (var index = itemIndex - 1; index >= _startIndex; index -= 1) {\n            startItemTop -= this.itemElementHeights[this.getIndexKey(index)] || 0;\n          }\n\n          this.setState({\n            status: 'MEASURE_DONE',\n            startItemTop: startItemTop\n          });\n        }\n\n        if (status === 'SWITCH_TO_RAW') {\n          /**\n           * After virtual list back to raw list,\n           * we update the `scrollTop` to real top instead of percentage top.\n           */\n          var _this$state$cacheScro = this.state.cacheScroll,\n              _itemIndex = _this$state$cacheScro.itemIndex,\n              relativeTop = _this$state$cacheScro.relativeTop;\n          var rawTop = relativeTop;\n\n          for (var _index = 0; _index < _itemIndex; _index += 1) {\n            rawTop -= this.itemElementHeights[this.getIndexKey(_index)] || 0;\n          }\n\n          this.lockScroll = true;\n          this.listRef.current.scrollTop = -rawTop;\n          this.setState({\n            status: 'MEASURE_DONE',\n            itemIndex: 0\n          });\n          requestAnimationFrame(function () {\n            requestAnimationFrame(function () {\n              _this2.lockScroll = false;\n            });\n          });\n        } else if (prevData.length !== data.length && changedItemIndex !== null && height && virtual !== false) {\n          /**\n           * Re-calculate the item position since `data` length changed.\n           * [IMPORTANT] We use relative position calculate here.\n           */\n          var originItemIndex = this.state.itemIndex;\n          var _this$state4 = this.state,\n              originItemOffsetPtg = _this$state4.itemOffsetPtg,\n              originStartIndex = _this$state4.startIndex,\n              originEndIndex = _this$state4.endIndex,\n              originScrollTop = _this$state4.scrollTop; // 1. Refresh item heights\n\n          this.collectItemHeights(); // 1. Get origin located item top\n\n          var originLocatedItemRelativeTop;\n\n          if (this.state.status === 'SWITCH_TO_VIRTUAL') {\n            originItemIndex = 0;\n            originLocatedItemRelativeTop = -this.state.scrollTop;\n          } else {\n            originLocatedItemRelativeTop = getItemRelativeTop({\n              itemIndex: originItemIndex,\n              itemOffsetPtg: originItemOffsetPtg,\n              itemElementHeights: this.itemElementHeights,\n              scrollPtg: getScrollPercentage({\n                scrollTop: originScrollTop,\n                scrollHeight: prevData.length * itemHeight,\n                clientHeight: this.listRef.current.clientHeight\n              }),\n              clientHeight: this.listRef.current.clientHeight,\n              getItemKey: function getItemKey(index) {\n                return _this2.getIndexKey(index, _this2.cachedProps);\n              }\n            });\n          } // 2. Find the compare item\n\n\n          var originCompareItemIndex = changedItemIndex - 1; // Use next one since there are not more item before removed\n\n          if (originCompareItemIndex < 0) {\n            originCompareItemIndex = 0;\n          } // 3. Find the compare item top\n\n\n          var originCompareItemTop = getCompareItemRelativeTop({\n            locatedItemRelativeTop: originLocatedItemRelativeTop,\n            locatedItemIndex: originItemIndex,\n            compareItemIndex: originCompareItemIndex,\n            startIndex: originStartIndex,\n            endIndex: originEndIndex,\n            getItemKey: function getItemKey(index) {\n              return _this2.getIndexKey(index, _this2.cachedProps);\n            },\n            itemElementHeights: this.itemElementHeights\n          });\n\n          if (nextStatus === 'SWITCH_TO_RAW') {\n            /**\n             * We will record current measure relative item top and apply in raw list after list turned\n             */\n            this.setState({\n              cacheScroll: {\n                itemIndex: originCompareItemIndex,\n                relativeTop: originCompareItemTop\n              }\n            });\n          } else {\n            this.internalScrollTo({\n              itemIndex: originCompareItemIndex,\n              relativeTop: originCompareItemTop\n            });\n          }\n        } else if (nextStatus === 'SWITCH_TO_RAW') {\n          // This is only trigger when height changes that all items can show in raw\n          // Let's reset back to top\n          this.setState({\n            cacheScroll: {\n              itemIndex: 0,\n              relativeTop: 0\n            }\n          });\n        }\n\n        this.cachedProps = this.props;\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        raf.cancel(this.rafId);\n      }\n    }, {\n      key: \"internalScrollTo\",\n      value: function internalScrollTo(relativeScroll) {\n        var _this3 = this;\n\n        var compareItemIndex = relativeScroll.itemIndex,\n            compareItemRelativeTop = relativeScroll.relativeTop;\n        var originScrollTop = this.state.scrollTop;\n        var _this$props4 = this.props,\n            data = _this$props4.data,\n            itemHeight = _this$props4.itemHeight,\n            height = _this$props4.height; // 1. Find the best match compare item top\n\n        var bestSimilarity = Number.MAX_VALUE;\n        var bestScrollTop = null;\n        var bestItemIndex = null;\n        var bestItemOffsetPtg = null;\n        var bestStartIndex = null;\n        var bestEndIndex = null;\n        var missSimilarity = 0;\n        var scrollHeight = data.length * itemHeight;\n        var clientHeight = this.listRef.current.clientHeight;\n        var maxScrollTop = scrollHeight - clientHeight;\n\n        for (var i = 0; i < maxScrollTop; i += 1) {\n          var scrollTop = getIndexByStartLoc(0, maxScrollTop, originScrollTop, i);\n          var scrollPtg = getScrollPercentage({\n            scrollTop: scrollTop,\n            scrollHeight: scrollHeight,\n            clientHeight: clientHeight\n          });\n          var visibleCount = Math.ceil(height / itemHeight);\n\n          var _getRangeIndex3 = getRangeIndex(scrollPtg, data.length, visibleCount),\n              itemIndex = _getRangeIndex3.itemIndex,\n              itemOffsetPtg = _getRangeIndex3.itemOffsetPtg,\n              startIndex = _getRangeIndex3.startIndex,\n              endIndex = _getRangeIndex3.endIndex; // No need to check if compare item out of the index to save performance\n\n\n          if (startIndex <= compareItemIndex && compareItemIndex <= endIndex) {\n            // 1.1 Get measure located item relative top\n            var locatedItemRelativeTop = getItemRelativeTop({\n              itemIndex: itemIndex,\n              itemOffsetPtg: itemOffsetPtg,\n              itemElementHeights: this.itemElementHeights,\n              scrollPtg: scrollPtg,\n              clientHeight: clientHeight,\n              getItemKey: this.getIndexKey\n            });\n            var compareItemTop = getCompareItemRelativeTop({\n              locatedItemRelativeTop: locatedItemRelativeTop,\n              locatedItemIndex: itemIndex,\n              compareItemIndex: compareItemIndex,\n              startIndex: startIndex,\n              endIndex: endIndex,\n              getItemKey: this.getIndexKey,\n              itemElementHeights: this.itemElementHeights\n            }); // 1.2 Find best match compare item top\n\n            var similarity = Math.abs(compareItemTop - compareItemRelativeTop);\n\n            if (similarity < bestSimilarity) {\n              bestSimilarity = similarity;\n              bestScrollTop = scrollTop;\n              bestItemIndex = itemIndex;\n              bestItemOffsetPtg = itemOffsetPtg;\n              bestStartIndex = startIndex;\n              bestEndIndex = endIndex;\n              missSimilarity = 0;\n            } else {\n              missSimilarity += 1;\n            }\n          } // If keeping 10 times not match similarity,\n          // check more scrollTop is meaningless.\n          // Here boundary is set to 10.\n\n\n          if (missSimilarity > 10) {\n            break;\n          }\n        } // 2. Re-scroll if has best scroll match\n\n\n        if (bestScrollTop !== null) {\n          this.lockScroll = true;\n          this.listRef.current.scrollTop = bestScrollTop;\n          this.setState({\n            status: 'MEASURE_START',\n            scrollTop: bestScrollTop,\n            itemIndex: bestItemIndex,\n            itemOffsetPtg: bestItemOffsetPtg,\n            startIndex: bestStartIndex,\n            endIndex: bestEndIndex\n          });\n          requestAnimationFrame(function () {\n            requestAnimationFrame(function () {\n              _this3.lockScroll = false;\n            });\n          });\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this$state5 = this.state,\n            isVirtual = _this$state5.isVirtual,\n            itemCount = _this$state5.itemCount;\n\n        var _this$props5 = this.props,\n            prefixCls = _this$props5.prefixCls,\n            style = _this$props5.style,\n            className = _this$props5.className,\n            _this$props5$componen = _this$props5.component,\n            Component = _this$props5$componen === void 0 ? 'div' : _this$props5$componen,\n            height = _this$props5.height,\n            itemHeight = _this$props5.itemHeight,\n            _this$props5$fullHeig = _this$props5.fullHeight,\n            fullHeight = _this$props5$fullHeig === void 0 ? true : _this$props5$fullHeig,\n            data = _this$props5.data,\n            children = _this$props5.children,\n            itemKey = _this$props5.itemKey,\n            onSkipRender = _this$props5.onSkipRender,\n            disabled = _this$props5.disabled,\n            virtual = _this$props5.virtual,\n            restProps = _objectWithoutProperties(_this$props5, [\"prefixCls\", \"style\", \"className\", \"component\", \"height\", \"itemHeight\", \"fullHeight\", \"data\", \"children\", \"itemKey\", \"onSkipRender\", \"disabled\", \"virtual\"]);\n\n        var mergedClassName = classNames(prefixCls, className); // Render pure list if not set height or height is enough for all items\n\n        if (!isVirtual) {\n          /**\n           * Virtual list switch is works on component updated.\n           * We should double check here if need cut the content.\n           */\n          var shouldVirtual = requireVirtual(height, itemHeight, data.length, virtual);\n          return React.createElement(Component, Object.assign({\n            style: height ? _objectSpread(_objectSpread({}, style), {}, _defineProperty({}, fullHeight ? 'height' : 'maxHeight', height), ScrollStyle) : style,\n            className: mergedClassName\n          }, restProps, {\n            onScroll: this.onRawScroll,\n            ref: this.listRef\n          }), React.createElement(Filler, {\n            prefixCls: prefixCls,\n            height: height\n          }, this.renderChildren(shouldVirtual ? data.slice(0, Math.ceil(height / itemHeight)) : data, 0, children)));\n        } // Use virtual list\n\n\n        var mergedStyle = _objectSpread(_objectSpread({}, style), {}, {\n          height: height\n        }, ScrollStyle);\n\n        var _this$state6 = this.state,\n            status = _this$state6.status,\n            startIndex = _this$state6.startIndex,\n            endIndex = _this$state6.endIndex,\n            startItemTop = _this$state6.startItemTop;\n        var contentHeight = itemCount * itemHeight * ITEM_SCALE_RATE;\n        return React.createElement(Component, Object.assign({\n          style: mergedStyle,\n          className: mergedClassName\n        }, restProps, {\n          onScroll: this.onScroll,\n          ref: this.listRef\n        }), React.createElement(Filler, {\n          prefixCls: prefixCls,\n          height: contentHeight,\n          offset: status === 'MEASURE_DONE' ? startItemTop : 0\n        }, this.renderChildren(data.slice(startIndex, endIndex + 1), startIndex, children)));\n      }\n    }], [{\n      key: \"getDerivedStateFromProps\",\n      value: function getDerivedStateFromProps(nextProps) {\n        if (!nextProps.disabled) {\n          return {\n            itemCount: nextProps.data.length\n          };\n        }\n\n        return null;\n      }\n    }]);\n\n    return List;\n  }(React.Component);\n\n  List.defaultProps = {\n    itemHeight: 15,\n    data: []\n  };\n  return List;\n}();\n\nexport default List;","map":{"version":3,"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","_objectWithoutProperties","excluded","_objectWithoutPropertiesLoose","sourceSymbolKeys","indexOf","prototype","propertyIsEnumerable","call","sourceKeys","_typeof","Symbol","iterator","constructor","_classCallCheck","instance","Constructor","TypeError","_defineProperties","props","descriptor","_createClass","protoProps","staticProps","_inherits","subClass","superClass","create","_setPrototypeOf","o","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","_getPrototypeOf","result","NewTarget","Reflect","construct","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","sham","Proxy","Date","toString","e","getPrototypeOf","React","classNames","raf","Filler","getElementScrollPercentage","getScrollPercentage","getNodeHeight","getRangeIndex","getItemAbsoluteTop","GHOST_ITEM_KEY","getItemRelativeTop","getCompareItemRelativeTop","alignScrollTop","requireVirtual","getIndexByStartLoc","findListDiffIndex","ScrollStyle","overflowY","overflowAnchor","ITEM_SCALE_RATE","List","_React$Component","_super","_this","listRef","createRef","itemElements","itemElementHeights","lockScroll","onScroll","event","_this$props","data","height","itemHeight","disabled","_this$listRef$current","current","originScrollTop","scrollTop","clientHeight","scrollHeight","state","scrollPtg","visibleCount","Math","ceil","_getRangeIndex","itemIndex","itemOffsetPtg","startIndex","endIndex","setState","status","triggerOnScroll","onRawScroll","getIndexKey","index","mergedProps","_mergedProps$data","item","undefined","console","error","getItemKey","_ref","itemKey","collectItemHeights","range","_ref2","eleKey","scrollTo","arg0","cancel","rafId","isVirtual","_this$props2","_arg0$align","align","findIndex","_this$state","relativeLocatedItemTop","max","min","relativeTop","mergedAlgin","shouldChange","abs","itemTop","_i","_eleKey","_getRangeIndex2","nextIndex","newOffsetPtg","_eleKey2","internalScrollTo","indexItemHeight","itemBottom","renderChildren","list","renderFunc","map","eleIndex","node","style","visibility","cloneElement","ref","ele","cachedProps","startItemTop","virtual","itemCount","componentDidMount","componentDidUpdate","_this2","_this$props3","onSkipRender","prevData","changedItemIndex","diff","_this$state2","nextStatus","_this$state3","_startIndex","locatedItemTop","_this$state$cacheScro","cacheScroll","_itemIndex","rawTop","_index","requestAnimationFrame","originItemIndex","_this$state4","originItemOffsetPtg","originStartIndex","originEndIndex","originLocatedItemRelativeTop","originCompareItemIndex","originCompareItemTop","locatedItemRelativeTop","locatedItemIndex","compareItemIndex","componentWillUnmount","relativeScroll","_this3","compareItemRelativeTop","_this$props4","bestSimilarity","Number","MAX_VALUE","bestScrollTop","bestItemIndex","bestItemOffsetPtg","bestStartIndex","bestEndIndex","missSimilarity","maxScrollTop","_getRangeIndex3","compareItemTop","similarity","render","_this$state5","_this$props5","prefixCls","className","_this$props5$componen","component","Component","_this$props5$fullHeig","fullHeight","children","restProps","mergedClassName","shouldVirtual","createElement","assign","slice","mergedStyle","_this$state6","contentHeight","offset","getDerivedStateFromProps","nextProps","defaultProps"],"sources":["E:/Work/PFE/Project folder/DocHelp-WA/node_modules/rc-tree/node_modules/rc-virtual-list/es/List.js"],"sourcesContent":["function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nimport * as React from 'react';\nimport classNames from 'classnames';\nimport raf from 'raf';\nimport Filler from './Filler';\nimport { getElementScrollPercentage, getScrollPercentage, getNodeHeight, getRangeIndex, getItemAbsoluteTop, GHOST_ITEM_KEY, getItemRelativeTop, getCompareItemRelativeTop, alignScrollTop, requireVirtual } from './utils/itemUtil';\nimport { getIndexByStartLoc, findListDiffIndex } from './utils/algorithmUtil';\nvar ScrollStyle = {\n  overflowY: 'auto',\n  overflowAnchor: 'none'\n};\nvar ITEM_SCALE_RATE = 1;\n/**\n * We use class component here since typescript can not support generic in function component\n *\n * Virtual list display logic:\n * 1. scroll / initialize trigger measure\n * 2. Get location item of current `scrollTop`\n * 3. [Render] Render visible items\n * 4. Get all the visible items height\n * 5. [Render] Update top item `margin-top` to fit the position\n *\n * Algorithm:\n * We split scroll bar into equal slice. An item with whatever height occupy the same range slice.\n * When `scrollTop` change,\n * it will calculate the item percentage position and move item to the position.\n * Then calculate other item position base on the located item.\n *\n * Concept:\n *\n * # located item\n * The base position item which other items position calculate base on.\n */\n\nvar List =\n/** @class */\nfunction () {\n  var List = /*#__PURE__*/function (_React$Component) {\n    _inherits(List, _React$Component);\n\n    var _super = _createSuper(List);\n\n    function List(props) {\n      var _this;\n\n      _classCallCheck(this, List);\n\n      _this = _super.call(this, props);\n      _this.listRef = React.createRef();\n      _this.itemElements = {};\n      _this.itemElementHeights = {};\n      /**\n       * Lock scroll process with `onScroll` event.\n       * This is used for `data` length change and `scrollTop` restore\n       */\n\n      _this.lockScroll = false;\n      /**\n       * Phase 2: Trigger render since we should re-calculate current position.\n       */\n\n      _this.onScroll = function (event) {\n        var _this$props = _this.props,\n            data = _this$props.data,\n            height = _this$props.height,\n            itemHeight = _this$props.itemHeight,\n            disabled = _this$props.disabled;\n        var _this$listRef$current = _this.listRef.current,\n            originScrollTop = _this$listRef$current.scrollTop,\n            clientHeight = _this$listRef$current.clientHeight,\n            scrollHeight = _this$listRef$current.scrollHeight;\n        var scrollTop = alignScrollTop(originScrollTop, scrollHeight - clientHeight); // Skip if `scrollTop` not change to avoid shake\n\n        if (scrollTop === _this.state.scrollTop || _this.lockScroll || disabled) {\n          return;\n        }\n\n        var scrollPtg = getElementScrollPercentage(_this.listRef.current);\n        var visibleCount = Math.ceil(height / itemHeight);\n\n        var _getRangeIndex = getRangeIndex(scrollPtg, data.length, visibleCount),\n            itemIndex = _getRangeIndex.itemIndex,\n            itemOffsetPtg = _getRangeIndex.itemOffsetPtg,\n            startIndex = _getRangeIndex.startIndex,\n            endIndex = _getRangeIndex.endIndex;\n\n        _this.setState({\n          status: 'MEASURE_START',\n          scrollTop: scrollTop,\n          itemIndex: itemIndex,\n          itemOffsetPtg: itemOffsetPtg,\n          startIndex: startIndex,\n          endIndex: endIndex\n        });\n\n        _this.triggerOnScroll(event);\n      };\n\n      _this.onRawScroll = function (event) {\n        var scrollTop = _this.listRef.current.scrollTop;\n\n        _this.setState({\n          scrollTop: scrollTop\n        });\n\n        _this.triggerOnScroll(event);\n      };\n\n      _this.triggerOnScroll = function (event) {\n        var onScroll = _this.props.onScroll;\n\n        if (onScroll && event) {\n          onScroll(event);\n        }\n      };\n\n      _this.getIndexKey = function (index, props) {\n        var mergedProps = props || _this.props;\n        var _mergedProps$data = mergedProps.data,\n            data = _mergedProps$data === void 0 ? [] : _mergedProps$data; // Return ghost key as latest index item\n\n        if (index === data.length) {\n          return GHOST_ITEM_KEY;\n        }\n\n        var item = data[index];\n        /* istanbul ignore next */\n\n        if (item === undefined) {\n          console.error('Not find index item. Please report this since it is a bug.');\n          return null;\n        }\n\n        return _this.getItemKey(item, mergedProps);\n      };\n\n      _this.getItemKey = function (item, props) {\n        var _ref = props || _this.props,\n            itemKey = _ref.itemKey;\n\n        return typeof itemKey === 'function' ? itemKey(item) : item[itemKey];\n      };\n      /**\n       * Collect current rendered dom element item heights\n       */\n\n\n      _this.collectItemHeights = function (range) {\n        var _ref2 = range || _this.state,\n            startIndex = _ref2.startIndex,\n            endIndex = _ref2.endIndex;\n\n        var data = _this.props.data; // Record here since measure item height will get warning in `render`\n\n        for (var index = startIndex; index <= endIndex; index += 1) {\n          var item = data[index]; // Only collect exist item height\n\n          if (item) {\n            var eleKey = _this.getItemKey(item);\n\n            _this.itemElementHeights[eleKey] = getNodeHeight(_this.itemElements[eleKey]);\n          }\n        }\n      };\n\n      _this.scrollTo = function (arg0) {\n        raf.cancel(_this.rafId);\n        _this.rafId = raf(function () {\n          // Number top\n          if (_typeof(arg0) === 'object') {\n            var isVirtual = _this.state.isVirtual;\n            var _this$props2 = _this.props,\n                height = _this$props2.height,\n                itemHeight = _this$props2.itemHeight,\n                data = _this$props2.data;\n            var _arg0$align = arg0.align,\n                align = _arg0$align === void 0 ? 'auto' : _arg0$align;\n            var index = 0;\n\n            if ('index' in arg0) {\n              index = arg0.index;\n            } else if ('key' in arg0) {\n              var key = arg0.key;\n              index = data.findIndex(function (item) {\n                return _this.getItemKey(item) === key;\n              });\n            }\n\n            var visibleCount = Math.ceil(height / itemHeight);\n            var item = data[index];\n\n            if (item) {\n              var clientHeight = _this.listRef.current.clientHeight;\n\n              if (isVirtual) {\n                // Calculate related data\n                var _this$state = _this.state,\n                    itemIndex = _this$state.itemIndex,\n                    itemOffsetPtg = _this$state.itemOffsetPtg;\n                var scrollTop = _this.listRef.current.scrollTop;\n                var scrollPtg = getElementScrollPercentage(_this.listRef.current);\n                var relativeLocatedItemTop = getItemRelativeTop({\n                  itemIndex: itemIndex,\n                  itemOffsetPtg: itemOffsetPtg,\n                  itemElementHeights: _this.itemElementHeights,\n                  scrollPtg: scrollPtg,\n                  clientHeight: clientHeight,\n                  getItemKey: _this.getIndexKey\n                }); // We will force render related items to collect height for re-location\n\n                _this.setState({\n                  startIndex: Math.max(0, index - visibleCount),\n                  endIndex: Math.min(data.length - 1, index + visibleCount)\n                }, function () {\n                  _this.collectItemHeights(); // Calculate related top\n\n\n                  var relativeTop;\n                  var mergedAlgin = align;\n\n                  if (align === 'auto') {\n                    var shouldChange = true; // Check if exist in the visible range\n\n                    if (Math.abs(itemIndex - index) < visibleCount) {\n                      var itemTop = relativeLocatedItemTop;\n\n                      if (index < itemIndex) {\n                        for (var i = index; i < itemIndex; i += 1) {\n                          var eleKey = _this.getIndexKey(i);\n\n                          itemTop -= _this.itemElementHeights[eleKey] || 0;\n                        }\n                      } else {\n                        for (var _i = itemIndex; _i <= index; _i += 1) {\n                          var _eleKey = _this.getIndexKey(_i);\n\n                          itemTop += _this.itemElementHeights[_eleKey] || 0;\n                        }\n                      }\n\n                      shouldChange = itemTop <= 0 || itemTop >= clientHeight;\n                    }\n\n                    if (shouldChange) {\n                      // Out of range will fall back to position align\n                      mergedAlgin = index < itemIndex ? 'top' : 'bottom';\n                    } else {\n                      var _getRangeIndex2 = getRangeIndex(scrollPtg, data.length, visibleCount),\n                          nextIndex = _getRangeIndex2.itemIndex,\n                          newOffsetPtg = _getRangeIndex2.itemOffsetPtg,\n                          startIndex = _getRangeIndex2.startIndex,\n                          endIndex = _getRangeIndex2.endIndex;\n\n                      _this.setState({\n                        scrollTop: scrollTop,\n                        itemIndex: nextIndex,\n                        itemOffsetPtg: newOffsetPtg,\n                        startIndex: startIndex,\n                        endIndex: endIndex\n                      });\n\n                      return;\n                    }\n                  } // Align with position should make scroll happen\n\n\n                  if (mergedAlgin === 'top') {\n                    relativeTop = 0;\n                  } else if (mergedAlgin === 'bottom') {\n                    var _eleKey2 = _this.getItemKey(item);\n\n                    relativeTop = clientHeight - _this.itemElementHeights[_eleKey2] || 0;\n                  }\n\n                  _this.internalScrollTo({\n                    itemIndex: index,\n                    relativeTop: relativeTop\n                  });\n                });\n              } else {\n                // Raw list without virtual scroll set position directly\n                _this.collectItemHeights({\n                  startIndex: 0,\n                  endIndex: data.length - 1\n                });\n\n                var mergedAlgin = align; // Collection index item position\n\n                var indexItemHeight = _this.itemElementHeights[_this.getIndexKey(index)];\n\n                var itemTop = 0;\n\n                for (var i = 0; i < index; i += 1) {\n                  var eleKey = _this.getIndexKey(i);\n\n                  itemTop += _this.itemElementHeights[eleKey] || 0;\n                }\n\n                var itemBottom = itemTop + indexItemHeight;\n\n                if (mergedAlgin === 'auto') {\n                  if (itemTop < _this.listRef.current.scrollTop) {\n                    mergedAlgin = 'top';\n                  } else if (itemBottom > _this.listRef.current.scrollTop + clientHeight) {\n                    mergedAlgin = 'bottom';\n                  }\n                }\n\n                if (mergedAlgin === 'top') {\n                  _this.listRef.current.scrollTop = itemTop;\n                } else if (mergedAlgin === 'bottom') {\n                  _this.listRef.current.scrollTop = itemTop - (clientHeight - indexItemHeight);\n                }\n              }\n            }\n          } else {\n            _this.listRef.current.scrollTop = arg0;\n          }\n        });\n      };\n      /**\n       * Phase 4: Render item and get all the visible items height\n       */\n\n\n      _this.renderChildren = function (list, startIndex, renderFunc) {\n        var status = _this.state.status; // We should measure rendered item height\n\n        return list.map(function (item, index) {\n          var eleIndex = startIndex + index;\n          var node = renderFunc(item, eleIndex, {\n            style: status === 'MEASURE_START' ? {\n              visibility: 'hidden'\n            } : {}\n          });\n\n          var eleKey = _this.getIndexKey(eleIndex); // Pass `key` and `ref` for internal measure\n\n\n          return React.cloneElement(node, {\n            key: eleKey,\n            ref: function ref(ele) {\n              _this.itemElements[eleKey] = ele;\n            }\n          });\n        });\n      };\n\n      _this.cachedProps = props;\n      _this.state = {\n        status: 'NONE',\n        scrollTop: null,\n        itemIndex: 0,\n        itemOffsetPtg: 0,\n        startIndex: 0,\n        endIndex: 0,\n        startItemTop: 0,\n        isVirtual: requireVirtual(props.height, props.itemHeight, props.data.length, props.virtual),\n        itemCount: props.data.length\n      };\n      return _this;\n    }\n\n    _createClass(List, [{\n      key: \"componentDidMount\",\n\n      /**\n       * Phase 1: Initial should sync with default scroll top\n       */\n      value: function componentDidMount() {\n        if (this.listRef.current) {\n          this.listRef.current.scrollTop = 0;\n          this.onScroll(null);\n        }\n      }\n      /**\n       * Phase 4: Record used item height\n       * Phase 5: Trigger re-render to use correct position\n       */\n\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate() {\n        var _this2 = this;\n\n        var status = this.state.status;\n        var _this$props3 = this.props,\n            data = _this$props3.data,\n            height = _this$props3.height,\n            itemHeight = _this$props3.itemHeight,\n            disabled = _this$props3.disabled,\n            onSkipRender = _this$props3.onSkipRender,\n            virtual = _this$props3.virtual;\n        var prevData = this.cachedProps.data || [];\n        var changedItemIndex = null;\n\n        if (prevData.length !== data.length) {\n          var diff = findListDiffIndex(prevData, data, this.getItemKey);\n          changedItemIndex = diff ? diff.index : null;\n        }\n\n        if (disabled) {\n          // Should trigger `onSkipRender` to tell that diff component is not render in the list\n          if (data.length > prevData.length) {\n            var _this$state2 = this.state,\n                startIndex = _this$state2.startIndex,\n                endIndex = _this$state2.endIndex;\n\n            if (onSkipRender && (changedItemIndex === null || changedItemIndex < startIndex || endIndex < changedItemIndex)) {\n              onSkipRender();\n            }\n          }\n\n          return;\n        }\n\n        var isVirtual = requireVirtual(height, itemHeight, data.length, virtual);\n        var nextStatus = status;\n\n        if (this.state.isVirtual !== isVirtual) {\n          nextStatus = isVirtual ? 'SWITCH_TO_VIRTUAL' : 'SWITCH_TO_RAW';\n          this.setState({\n            isVirtual: isVirtual,\n            status: nextStatus\n          });\n          /**\n           * We will wait a tick to let list turn to virtual list.\n           * And then use virtual list sync logic to adjust the scroll.\n           */\n\n          if (nextStatus === 'SWITCH_TO_VIRTUAL') {\n            return;\n          }\n        }\n\n        if (status === 'MEASURE_START') {\n          var _this$state3 = this.state,\n              _startIndex = _this$state3.startIndex,\n              itemIndex = _this$state3.itemIndex,\n              itemOffsetPtg = _this$state3.itemOffsetPtg;\n          var scrollTop = this.listRef.current.scrollTop; // Record here since measure item height will get warning in `render`\n\n          this.collectItemHeights(); // Calculate top visible item top offset\n\n          var locatedItemTop = getItemAbsoluteTop({\n            itemIndex: itemIndex,\n            itemOffsetPtg: itemOffsetPtg,\n            itemElementHeights: this.itemElementHeights,\n            scrollTop: scrollTop,\n            scrollPtg: getElementScrollPercentage(this.listRef.current),\n            clientHeight: this.listRef.current.clientHeight,\n            getItemKey: this.getIndexKey\n          });\n          var startItemTop = locatedItemTop;\n\n          for (var index = itemIndex - 1; index >= _startIndex; index -= 1) {\n            startItemTop -= this.itemElementHeights[this.getIndexKey(index)] || 0;\n          }\n\n          this.setState({\n            status: 'MEASURE_DONE',\n            startItemTop: startItemTop\n          });\n        }\n\n        if (status === 'SWITCH_TO_RAW') {\n          /**\n           * After virtual list back to raw list,\n           * we update the `scrollTop` to real top instead of percentage top.\n           */\n          var _this$state$cacheScro = this.state.cacheScroll,\n              _itemIndex = _this$state$cacheScro.itemIndex,\n              relativeTop = _this$state$cacheScro.relativeTop;\n          var rawTop = relativeTop;\n\n          for (var _index = 0; _index < _itemIndex; _index += 1) {\n            rawTop -= this.itemElementHeights[this.getIndexKey(_index)] || 0;\n          }\n\n          this.lockScroll = true;\n          this.listRef.current.scrollTop = -rawTop;\n          this.setState({\n            status: 'MEASURE_DONE',\n            itemIndex: 0\n          });\n          requestAnimationFrame(function () {\n            requestAnimationFrame(function () {\n              _this2.lockScroll = false;\n            });\n          });\n        } else if (prevData.length !== data.length && changedItemIndex !== null && height && virtual !== false) {\n          /**\n           * Re-calculate the item position since `data` length changed.\n           * [IMPORTANT] We use relative position calculate here.\n           */\n          var originItemIndex = this.state.itemIndex;\n          var _this$state4 = this.state,\n              originItemOffsetPtg = _this$state4.itemOffsetPtg,\n              originStartIndex = _this$state4.startIndex,\n              originEndIndex = _this$state4.endIndex,\n              originScrollTop = _this$state4.scrollTop; // 1. Refresh item heights\n\n          this.collectItemHeights(); // 1. Get origin located item top\n\n          var originLocatedItemRelativeTop;\n\n          if (this.state.status === 'SWITCH_TO_VIRTUAL') {\n            originItemIndex = 0;\n            originLocatedItemRelativeTop = -this.state.scrollTop;\n          } else {\n            originLocatedItemRelativeTop = getItemRelativeTop({\n              itemIndex: originItemIndex,\n              itemOffsetPtg: originItemOffsetPtg,\n              itemElementHeights: this.itemElementHeights,\n              scrollPtg: getScrollPercentage({\n                scrollTop: originScrollTop,\n                scrollHeight: prevData.length * itemHeight,\n                clientHeight: this.listRef.current.clientHeight\n              }),\n              clientHeight: this.listRef.current.clientHeight,\n              getItemKey: function getItemKey(index) {\n                return _this2.getIndexKey(index, _this2.cachedProps);\n              }\n            });\n          } // 2. Find the compare item\n\n\n          var originCompareItemIndex = changedItemIndex - 1; // Use next one since there are not more item before removed\n\n          if (originCompareItemIndex < 0) {\n            originCompareItemIndex = 0;\n          } // 3. Find the compare item top\n\n\n          var originCompareItemTop = getCompareItemRelativeTop({\n            locatedItemRelativeTop: originLocatedItemRelativeTop,\n            locatedItemIndex: originItemIndex,\n            compareItemIndex: originCompareItemIndex,\n            startIndex: originStartIndex,\n            endIndex: originEndIndex,\n            getItemKey: function getItemKey(index) {\n              return _this2.getIndexKey(index, _this2.cachedProps);\n            },\n            itemElementHeights: this.itemElementHeights\n          });\n\n          if (nextStatus === 'SWITCH_TO_RAW') {\n            /**\n             * We will record current measure relative item top and apply in raw list after list turned\n             */\n            this.setState({\n              cacheScroll: {\n                itemIndex: originCompareItemIndex,\n                relativeTop: originCompareItemTop\n              }\n            });\n          } else {\n            this.internalScrollTo({\n              itemIndex: originCompareItemIndex,\n              relativeTop: originCompareItemTop\n            });\n          }\n        } else if (nextStatus === 'SWITCH_TO_RAW') {\n          // This is only trigger when height changes that all items can show in raw\n          // Let's reset back to top\n          this.setState({\n            cacheScroll: {\n              itemIndex: 0,\n              relativeTop: 0\n            }\n          });\n        }\n\n        this.cachedProps = this.props;\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        raf.cancel(this.rafId);\n      }\n    }, {\n      key: \"internalScrollTo\",\n      value: function internalScrollTo(relativeScroll) {\n        var _this3 = this;\n\n        var compareItemIndex = relativeScroll.itemIndex,\n            compareItemRelativeTop = relativeScroll.relativeTop;\n        var originScrollTop = this.state.scrollTop;\n        var _this$props4 = this.props,\n            data = _this$props4.data,\n            itemHeight = _this$props4.itemHeight,\n            height = _this$props4.height; // 1. Find the best match compare item top\n\n        var bestSimilarity = Number.MAX_VALUE;\n        var bestScrollTop = null;\n        var bestItemIndex = null;\n        var bestItemOffsetPtg = null;\n        var bestStartIndex = null;\n        var bestEndIndex = null;\n        var missSimilarity = 0;\n        var scrollHeight = data.length * itemHeight;\n        var clientHeight = this.listRef.current.clientHeight;\n        var maxScrollTop = scrollHeight - clientHeight;\n\n        for (var i = 0; i < maxScrollTop; i += 1) {\n          var scrollTop = getIndexByStartLoc(0, maxScrollTop, originScrollTop, i);\n          var scrollPtg = getScrollPercentage({\n            scrollTop: scrollTop,\n            scrollHeight: scrollHeight,\n            clientHeight: clientHeight\n          });\n          var visibleCount = Math.ceil(height / itemHeight);\n\n          var _getRangeIndex3 = getRangeIndex(scrollPtg, data.length, visibleCount),\n              itemIndex = _getRangeIndex3.itemIndex,\n              itemOffsetPtg = _getRangeIndex3.itemOffsetPtg,\n              startIndex = _getRangeIndex3.startIndex,\n              endIndex = _getRangeIndex3.endIndex; // No need to check if compare item out of the index to save performance\n\n\n          if (startIndex <= compareItemIndex && compareItemIndex <= endIndex) {\n            // 1.1 Get measure located item relative top\n            var locatedItemRelativeTop = getItemRelativeTop({\n              itemIndex: itemIndex,\n              itemOffsetPtg: itemOffsetPtg,\n              itemElementHeights: this.itemElementHeights,\n              scrollPtg: scrollPtg,\n              clientHeight: clientHeight,\n              getItemKey: this.getIndexKey\n            });\n            var compareItemTop = getCompareItemRelativeTop({\n              locatedItemRelativeTop: locatedItemRelativeTop,\n              locatedItemIndex: itemIndex,\n              compareItemIndex: compareItemIndex,\n              startIndex: startIndex,\n              endIndex: endIndex,\n              getItemKey: this.getIndexKey,\n              itemElementHeights: this.itemElementHeights\n            }); // 1.2 Find best match compare item top\n\n            var similarity = Math.abs(compareItemTop - compareItemRelativeTop);\n\n            if (similarity < bestSimilarity) {\n              bestSimilarity = similarity;\n              bestScrollTop = scrollTop;\n              bestItemIndex = itemIndex;\n              bestItemOffsetPtg = itemOffsetPtg;\n              bestStartIndex = startIndex;\n              bestEndIndex = endIndex;\n              missSimilarity = 0;\n            } else {\n              missSimilarity += 1;\n            }\n          } // If keeping 10 times not match similarity,\n          // check more scrollTop is meaningless.\n          // Here boundary is set to 10.\n\n\n          if (missSimilarity > 10) {\n            break;\n          }\n        } // 2. Re-scroll if has best scroll match\n\n\n        if (bestScrollTop !== null) {\n          this.lockScroll = true;\n          this.listRef.current.scrollTop = bestScrollTop;\n          this.setState({\n            status: 'MEASURE_START',\n            scrollTop: bestScrollTop,\n            itemIndex: bestItemIndex,\n            itemOffsetPtg: bestItemOffsetPtg,\n            startIndex: bestStartIndex,\n            endIndex: bestEndIndex\n          });\n          requestAnimationFrame(function () {\n            requestAnimationFrame(function () {\n              _this3.lockScroll = false;\n            });\n          });\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this$state5 = this.state,\n            isVirtual = _this$state5.isVirtual,\n            itemCount = _this$state5.itemCount;\n\n        var _this$props5 = this.props,\n            prefixCls = _this$props5.prefixCls,\n            style = _this$props5.style,\n            className = _this$props5.className,\n            _this$props5$componen = _this$props5.component,\n            Component = _this$props5$componen === void 0 ? 'div' : _this$props5$componen,\n            height = _this$props5.height,\n            itemHeight = _this$props5.itemHeight,\n            _this$props5$fullHeig = _this$props5.fullHeight,\n            fullHeight = _this$props5$fullHeig === void 0 ? true : _this$props5$fullHeig,\n            data = _this$props5.data,\n            children = _this$props5.children,\n            itemKey = _this$props5.itemKey,\n            onSkipRender = _this$props5.onSkipRender,\n            disabled = _this$props5.disabled,\n            virtual = _this$props5.virtual,\n            restProps = _objectWithoutProperties(_this$props5, [\"prefixCls\", \"style\", \"className\", \"component\", \"height\", \"itemHeight\", \"fullHeight\", \"data\", \"children\", \"itemKey\", \"onSkipRender\", \"disabled\", \"virtual\"]);\n\n        var mergedClassName = classNames(prefixCls, className); // Render pure list if not set height or height is enough for all items\n\n        if (!isVirtual) {\n          /**\n           * Virtual list switch is works on component updated.\n           * We should double check here if need cut the content.\n           */\n          var shouldVirtual = requireVirtual(height, itemHeight, data.length, virtual);\n          return React.createElement(Component, Object.assign({\n            style: height ? _objectSpread(_objectSpread({}, style), {}, _defineProperty({}, fullHeight ? 'height' : 'maxHeight', height), ScrollStyle) : style,\n            className: mergedClassName\n          }, restProps, {\n            onScroll: this.onRawScroll,\n            ref: this.listRef\n          }), React.createElement(Filler, {\n            prefixCls: prefixCls,\n            height: height\n          }, this.renderChildren(shouldVirtual ? data.slice(0, Math.ceil(height / itemHeight)) : data, 0, children)));\n        } // Use virtual list\n\n\n        var mergedStyle = _objectSpread(_objectSpread({}, style), {}, {\n          height: height\n        }, ScrollStyle);\n\n        var _this$state6 = this.state,\n            status = _this$state6.status,\n            startIndex = _this$state6.startIndex,\n            endIndex = _this$state6.endIndex,\n            startItemTop = _this$state6.startItemTop;\n        var contentHeight = itemCount * itemHeight * ITEM_SCALE_RATE;\n        return React.createElement(Component, Object.assign({\n          style: mergedStyle,\n          className: mergedClassName\n        }, restProps, {\n          onScroll: this.onScroll,\n          ref: this.listRef\n        }), React.createElement(Filler, {\n          prefixCls: prefixCls,\n          height: contentHeight,\n          offset: status === 'MEASURE_DONE' ? startItemTop : 0\n        }, this.renderChildren(data.slice(startIndex, endIndex + 1), startIndex, children)));\n      }\n    }], [{\n      key: \"getDerivedStateFromProps\",\n      value: function getDerivedStateFromProps(nextProps) {\n        if (!nextProps.disabled) {\n          return {\n            itemCount: nextProps.data.length\n          };\n        }\n\n        return null;\n      }\n    }]);\n\n    return List;\n  }(React.Component);\n\n  List.defaultProps = {\n    itemHeight: 15,\n    data: []\n  };\n  return List;\n}();\n\nexport default List;"],"mappings":"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"},"metadata":{},"sourceType":"module"}