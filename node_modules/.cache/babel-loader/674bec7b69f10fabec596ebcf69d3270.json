{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule removeRangeFromContentState\n * @format\n * \n */\n'use strict';\n\nvar ContentBlockNode = require('./ContentBlockNode');\n\nvar Immutable = require('immutable');\n\nvar getNextDelimiterBlockKey = require('./getNextDelimiterBlockKey');\n\nvar List = Immutable.List,\n    Map = Immutable.Map;\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n/**\n * Ancestors needs to be preserved when there are non selected\n * children to make sure we do not leave any orphans behind\n */\n\n\nvar getAncestorsKeys = function getAncestorsKeys(blockKey, blockMap) {\n  var parents = [];\n\n  if (!blockKey) {\n    return parents;\n  }\n\n  var blockNode = blockMap.get(blockKey);\n\n  while (blockNode && blockNode.getParentKey()) {\n    var parentKey = blockNode.getParentKey();\n\n    if (parentKey) {\n      parents.push(parentKey);\n    }\n\n    blockNode = parentKey ? blockMap.get(parentKey) : null;\n  }\n\n  return parents;\n};\n/**\n * Get all next delimiter keys until we hit a root delimiter and return\n * an array of key references\n */\n\n\nvar getNextDelimitersBlockKeys = function getNextDelimitersBlockKeys(block, blockMap) {\n  var nextDelimiters = [];\n\n  if (!block) {\n    return nextDelimiters;\n  }\n\n  var nextDelimiter = getNextDelimiterBlockKey(block, blockMap);\n\n  while (nextDelimiter && blockMap.get(nextDelimiter)) {\n    var _block = blockMap.get(nextDelimiter);\n\n    nextDelimiters.push(nextDelimiter); // we do not need to keep checking all root node siblings, just the first occurance\n\n    nextDelimiter = _block.getParentKey() ? getNextDelimiterBlockKey(_block, blockMap) : null;\n  }\n\n  return nextDelimiters;\n};\n\nvar getNextValidSibling = function getNextValidSibling(block, blockMap, originalBlockMap) {\n  if (!block) {\n    return null;\n  } // note that we need to make sure we refer to the original block since this\n  // function is called within a withMutations\n\n\n  var nextValidSiblingKey = originalBlockMap.get(block.getKey()).getNextSiblingKey();\n\n  while (nextValidSiblingKey && !blockMap.get(nextValidSiblingKey)) {\n    nextValidSiblingKey = originalBlockMap.get(nextValidSiblingKey).getNextSiblingKey() || null;\n  }\n\n  return nextValidSiblingKey;\n};\n\nvar getPrevValidSibling = function getPrevValidSibling(block, blockMap, originalBlockMap) {\n  if (!block) {\n    return null;\n  } // note that we need to make sure we refer to the original block since this\n  // function is called within a withMutations\n\n\n  var prevValidSiblingKey = originalBlockMap.get(block.getKey()).getPrevSiblingKey();\n\n  while (prevValidSiblingKey && !blockMap.get(prevValidSiblingKey)) {\n    prevValidSiblingKey = originalBlockMap.get(prevValidSiblingKey).getPrevSiblingKey() || null;\n  }\n\n  return prevValidSiblingKey;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, startBlock, endBlock, originalBlockMap) {\n  return blockMap.withMutations(function (blocks) {\n    // update start block if its retained\n    transformBlock(startBlock.getKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(startBlock, blocks, originalBlockMap),\n        prevSibling: getPrevValidSibling(startBlock, blocks, originalBlockMap)\n      });\n    }); // update endblock if its retained\n\n    transformBlock(endBlock.getKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(endBlock, blocks, originalBlockMap),\n        prevSibling: getPrevValidSibling(endBlock, blocks, originalBlockMap)\n      });\n    }); // update start block parent ancestors\n\n    getAncestorsKeys(startBlock.getKey(), originalBlockMap).forEach(function (parentKey) {\n      return transformBlock(parentKey, blocks, function (block) {\n        return block.merge({\n          children: block.getChildKeys().filter(function (key) {\n            return blocks.get(key);\n          }),\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    }); // update start block next - can only happen if startBlock == endBlock\n\n    transformBlock(startBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: startBlock.getPrevSiblingKey()\n      });\n    }); // update start block prev\n\n    transformBlock(startBlock.getPrevSiblingKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(startBlock, blocks, originalBlockMap)\n      });\n    }); // update end block next\n\n    transformBlock(endBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: getPrevValidSibling(endBlock, blocks, originalBlockMap)\n      });\n    }); // update end block prev\n\n    transformBlock(endBlock.getPrevSiblingKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: endBlock.getNextSiblingKey()\n      });\n    }); // update end block parent ancestors\n\n    getAncestorsKeys(endBlock.getKey(), originalBlockMap).forEach(function (parentKey) {\n      transformBlock(parentKey, blocks, function (block) {\n        return block.merge({\n          children: block.getChildKeys().filter(function (key) {\n            return blocks.get(key);\n          }),\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    }); // update next delimiters all the way to a root delimiter\n\n    getNextDelimitersBlockKeys(endBlock, originalBlockMap).forEach(function (delimiterKey) {\n      return transformBlock(delimiterKey, blocks, function (block) {\n        return block.merge({\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    });\n  });\n};\n\nvar removeRangeFromContentState = function removeRangeFromContentState(contentState, selectionState) {\n  if (selectionState.isCollapsed()) {\n    return contentState;\n  }\n\n  var blockMap = contentState.getBlockMap();\n  var startKey = selectionState.getStartKey();\n  var startOffset = selectionState.getStartOffset();\n  var endKey = selectionState.getEndKey();\n  var endOffset = selectionState.getEndOffset();\n  var startBlock = blockMap.get(startKey);\n  var endBlock = blockMap.get(endKey); // we assume that ContentBlockNode and ContentBlocks are not mixed together\n\n  var isExperimentalTreeBlock = startBlock instanceof ContentBlockNode; // used to retain blocks that should not be deleted to avoid orphan children\n\n  var parentAncestors = [];\n\n  if (isExperimentalTreeBlock) {\n    var endBlockchildrenKeys = endBlock.getChildKeys();\n    var endBlockAncestors = getAncestorsKeys(endKey, blockMap); // endBlock has unselected sibblings so we can not remove its ancestors parents\n\n    if (endBlock.getNextSiblingKey()) {\n      parentAncestors = parentAncestors.concat(endBlockAncestors);\n    } // endBlock has children so can not remove this block or any of its ancestors\n\n\n    if (!endBlockchildrenKeys.isEmpty()) {\n      parentAncestors = parentAncestors.concat(endBlockAncestors.concat([endKey]));\n    } // we need to retain all ancestors of the next delimiter block\n\n\n    parentAncestors = parentAncestors.concat(getAncestorsKeys(getNextDelimiterBlockKey(endBlock, blockMap), blockMap));\n  }\n\n  var characterList = void 0;\n\n  if (startBlock === endBlock) {\n    characterList = removeFromList(startBlock.getCharacterList(), startOffset, endOffset);\n  } else {\n    characterList = startBlock.getCharacterList().slice(0, startOffset).concat(endBlock.getCharacterList().slice(endOffset));\n  }\n\n  var modifiedStart = startBlock.merge({\n    text: startBlock.getText().slice(0, startOffset) + endBlock.getText().slice(endOffset),\n    characterList: characterList\n  });\n  var newBlocks = blockMap.toSeq().skipUntil(function (_, k) {\n    return k === startKey;\n  }).takeUntil(function (_, k) {\n    return k === endKey;\n  }).filter(function (_, k) {\n    return parentAncestors.indexOf(k) === -1;\n  }).concat(Map([[endKey, null]])).map(function (_, k) {\n    return k === startKey ? modifiedStart : null;\n  });\n  var updatedBlockMap = blockMap.merge(newBlocks).filter(function (block) {\n    return !!block;\n  });\n\n  if (isExperimentalTreeBlock) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, startBlock, endBlock, blockMap);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: startKey,\n      anchorOffset: startOffset,\n      focusKey: startKey,\n      focusOffset: startOffset,\n      isBackward: false\n    })\n  });\n};\n/**\n * Maintain persistence for target list when removing characters on the\n * head and tail of the character list.\n */\n\n\nvar removeFromList = function removeFromList(targetList, startOffset, endOffset) {\n  if (startOffset === 0) {\n    while (startOffset < endOffset) {\n      targetList = targetList.shift();\n      startOffset++;\n    }\n  } else if (endOffset === targetList.count()) {\n    while (endOffset > startOffset) {\n      targetList = targetList.pop();\n      endOffset--;\n    }\n  } else {\n    var head = targetList.slice(0, startOffset);\n    var tail = targetList.slice(endOffset);\n    targetList = head.concat(tail).toList();\n  }\n\n  return targetList;\n};\n\nmodule.exports = removeRangeFromContentState;","map":{"version":3,"names":["ContentBlockNode","require","Immutable","getNextDelimiterBlockKey","List","Map","transformBlock","key","blockMap","func","block","get","set","getAncestorsKeys","blockKey","parents","blockNode","getParentKey","parentKey","push","getNextDelimitersBlockKeys","nextDelimiters","nextDelimiter","_block","getNextValidSibling","originalBlockMap","nextValidSiblingKey","getKey","getNextSiblingKey","getPrevValidSibling","prevValidSiblingKey","getPrevSiblingKey","updateBlockMapLinks","startBlock","endBlock","withMutations","blocks","merge","nextSibling","prevSibling","forEach","children","getChildKeys","filter","delimiterKey","removeRangeFromContentState","contentState","selectionState","isCollapsed","getBlockMap","startKey","getStartKey","startOffset","getStartOffset","endKey","getEndKey","endOffset","getEndOffset","isExperimentalTreeBlock","parentAncestors","endBlockchildrenKeys","endBlockAncestors","concat","isEmpty","characterList","removeFromList","getCharacterList","slice","modifiedStart","text","getText","newBlocks","toSeq","skipUntil","_","k","takeUntil","indexOf","map","updatedBlockMap","selectionBefore","selectionAfter","anchorKey","anchorOffset","focusKey","focusOffset","isBackward","targetList","shift","count","pop","head","tail","toList","module","exports"],"sources":["E:/Work/PFE/Project folder/react/node_modules/draft-js/lib/removeRangeFromContentState.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule removeRangeFromContentState\n * @format\n * \n */\n\n'use strict';\n\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\n\nvar getNextDelimiterBlockKey = require('./getNextDelimiterBlockKey');\n\nvar List = Immutable.List,\n    Map = Immutable.Map;\n\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n\n/**\n * Ancestors needs to be preserved when there are non selected\n * children to make sure we do not leave any orphans behind\n */\nvar getAncestorsKeys = function getAncestorsKeys(blockKey, blockMap) {\n  var parents = [];\n\n  if (!blockKey) {\n    return parents;\n  }\n\n  var blockNode = blockMap.get(blockKey);\n  while (blockNode && blockNode.getParentKey()) {\n    var parentKey = blockNode.getParentKey();\n    if (parentKey) {\n      parents.push(parentKey);\n    }\n    blockNode = parentKey ? blockMap.get(parentKey) : null;\n  }\n\n  return parents;\n};\n\n/**\n * Get all next delimiter keys until we hit a root delimiter and return\n * an array of key references\n */\nvar getNextDelimitersBlockKeys = function getNextDelimitersBlockKeys(block, blockMap) {\n  var nextDelimiters = [];\n\n  if (!block) {\n    return nextDelimiters;\n  }\n\n  var nextDelimiter = getNextDelimiterBlockKey(block, blockMap);\n  while (nextDelimiter && blockMap.get(nextDelimiter)) {\n    var _block = blockMap.get(nextDelimiter);\n    nextDelimiters.push(nextDelimiter);\n\n    // we do not need to keep checking all root node siblings, just the first occurance\n    nextDelimiter = _block.getParentKey() ? getNextDelimiterBlockKey(_block, blockMap) : null;\n  }\n\n  return nextDelimiters;\n};\n\nvar getNextValidSibling = function getNextValidSibling(block, blockMap, originalBlockMap) {\n  if (!block) {\n    return null;\n  }\n\n  // note that we need to make sure we refer to the original block since this\n  // function is called within a withMutations\n  var nextValidSiblingKey = originalBlockMap.get(block.getKey()).getNextSiblingKey();\n\n  while (nextValidSiblingKey && !blockMap.get(nextValidSiblingKey)) {\n    nextValidSiblingKey = originalBlockMap.get(nextValidSiblingKey).getNextSiblingKey() || null;\n  }\n\n  return nextValidSiblingKey;\n};\n\nvar getPrevValidSibling = function getPrevValidSibling(block, blockMap, originalBlockMap) {\n  if (!block) {\n    return null;\n  }\n\n  // note that we need to make sure we refer to the original block since this\n  // function is called within a withMutations\n  var prevValidSiblingKey = originalBlockMap.get(block.getKey()).getPrevSiblingKey();\n\n  while (prevValidSiblingKey && !blockMap.get(prevValidSiblingKey)) {\n    prevValidSiblingKey = originalBlockMap.get(prevValidSiblingKey).getPrevSiblingKey() || null;\n  }\n\n  return prevValidSiblingKey;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, startBlock, endBlock, originalBlockMap) {\n  return blockMap.withMutations(function (blocks) {\n    // update start block if its retained\n    transformBlock(startBlock.getKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(startBlock, blocks, originalBlockMap),\n        prevSibling: getPrevValidSibling(startBlock, blocks, originalBlockMap)\n      });\n    });\n\n    // update endblock if its retained\n    transformBlock(endBlock.getKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(endBlock, blocks, originalBlockMap),\n        prevSibling: getPrevValidSibling(endBlock, blocks, originalBlockMap)\n      });\n    });\n\n    // update start block parent ancestors\n    getAncestorsKeys(startBlock.getKey(), originalBlockMap).forEach(function (parentKey) {\n      return transformBlock(parentKey, blocks, function (block) {\n        return block.merge({\n          children: block.getChildKeys().filter(function (key) {\n            return blocks.get(key);\n          }),\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    });\n\n    // update start block next - can only happen if startBlock == endBlock\n    transformBlock(startBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: startBlock.getPrevSiblingKey()\n      });\n    });\n\n    // update start block prev\n    transformBlock(startBlock.getPrevSiblingKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: getNextValidSibling(startBlock, blocks, originalBlockMap)\n      });\n    });\n\n    // update end block next\n    transformBlock(endBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: getPrevValidSibling(endBlock, blocks, originalBlockMap)\n      });\n    });\n\n    // update end block prev\n    transformBlock(endBlock.getPrevSiblingKey(), blocks, function (block) {\n      return block.merge({\n        nextSibling: endBlock.getNextSiblingKey()\n      });\n    });\n\n    // update end block parent ancestors\n    getAncestorsKeys(endBlock.getKey(), originalBlockMap).forEach(function (parentKey) {\n      transformBlock(parentKey, blocks, function (block) {\n        return block.merge({\n          children: block.getChildKeys().filter(function (key) {\n            return blocks.get(key);\n          }),\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    });\n\n    // update next delimiters all the way to a root delimiter\n    getNextDelimitersBlockKeys(endBlock, originalBlockMap).forEach(function (delimiterKey) {\n      return transformBlock(delimiterKey, blocks, function (block) {\n        return block.merge({\n          nextSibling: getNextValidSibling(block, blocks, originalBlockMap),\n          prevSibling: getPrevValidSibling(block, blocks, originalBlockMap)\n        });\n      });\n    });\n  });\n};\n\nvar removeRangeFromContentState = function removeRangeFromContentState(contentState, selectionState) {\n  if (selectionState.isCollapsed()) {\n    return contentState;\n  }\n\n  var blockMap = contentState.getBlockMap();\n  var startKey = selectionState.getStartKey();\n  var startOffset = selectionState.getStartOffset();\n  var endKey = selectionState.getEndKey();\n  var endOffset = selectionState.getEndOffset();\n\n  var startBlock = blockMap.get(startKey);\n  var endBlock = blockMap.get(endKey);\n\n  // we assume that ContentBlockNode and ContentBlocks are not mixed together\n  var isExperimentalTreeBlock = startBlock instanceof ContentBlockNode;\n\n  // used to retain blocks that should not be deleted to avoid orphan children\n  var parentAncestors = [];\n\n  if (isExperimentalTreeBlock) {\n    var endBlockchildrenKeys = endBlock.getChildKeys();\n    var endBlockAncestors = getAncestorsKeys(endKey, blockMap);\n\n    // endBlock has unselected sibblings so we can not remove its ancestors parents\n    if (endBlock.getNextSiblingKey()) {\n      parentAncestors = parentAncestors.concat(endBlockAncestors);\n    }\n\n    // endBlock has children so can not remove this block or any of its ancestors\n    if (!endBlockchildrenKeys.isEmpty()) {\n      parentAncestors = parentAncestors.concat(endBlockAncestors.concat([endKey]));\n    }\n\n    // we need to retain all ancestors of the next delimiter block\n    parentAncestors = parentAncestors.concat(getAncestorsKeys(getNextDelimiterBlockKey(endBlock, blockMap), blockMap));\n  }\n\n  var characterList = void 0;\n\n  if (startBlock === endBlock) {\n    characterList = removeFromList(startBlock.getCharacterList(), startOffset, endOffset);\n  } else {\n    characterList = startBlock.getCharacterList().slice(0, startOffset).concat(endBlock.getCharacterList().slice(endOffset));\n  }\n\n  var modifiedStart = startBlock.merge({\n    text: startBlock.getText().slice(0, startOffset) + endBlock.getText().slice(endOffset),\n    characterList: characterList\n  });\n\n  var newBlocks = blockMap.toSeq().skipUntil(function (_, k) {\n    return k === startKey;\n  }).takeUntil(function (_, k) {\n    return k === endKey;\n  }).filter(function (_, k) {\n    return parentAncestors.indexOf(k) === -1;\n  }).concat(Map([[endKey, null]])).map(function (_, k) {\n    return k === startKey ? modifiedStart : null;\n  });\n\n  var updatedBlockMap = blockMap.merge(newBlocks).filter(function (block) {\n    return !!block;\n  });\n\n  if (isExperimentalTreeBlock) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, startBlock, endBlock, blockMap);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: startKey,\n      anchorOffset: startOffset,\n      focusKey: startKey,\n      focusOffset: startOffset,\n      isBackward: false\n    })\n  });\n};\n\n/**\n * Maintain persistence for target list when removing characters on the\n * head and tail of the character list.\n */\nvar removeFromList = function removeFromList(targetList, startOffset, endOffset) {\n  if (startOffset === 0) {\n    while (startOffset < endOffset) {\n      targetList = targetList.shift();\n      startOffset++;\n    }\n  } else if (endOffset === targetList.count()) {\n    while (endOffset > startOffset) {\n      targetList = targetList.pop();\n      endOffset--;\n    }\n  } else {\n    var head = targetList.slice(0, startOffset);\n    var tail = targetList.slice(endOffset);\n    targetList = head.concat(tail).toList();\n  }\n  return targetList;\n};\n\nmodule.exports = removeRangeFromContentState;"],"mappings":"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"},"metadata":{},"sourceType":"script"}